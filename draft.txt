



Internet Engineering Task Force                                 E. Kline
Internet-Draft                                           Google Japan KK
Intended status: Informational                          October 31, 2015
Expires: May 3, 2016


             Multiple Provisioning Domains API Requirements
                    draft-kline-mif-mpvd-api-reqs-00

Abstract

   RFC 7556 [RFC7556] provides the essential conceptual guidance an API
   designer would need to support use of PvDs.  This document aims to
   capture the requirements for an API that can be used by applications
   that would be considered "advanced", according to section 6.3 [1] of
   RFC 7556 [RFC7556].  The "basic" [2] and "intermediate" [3] API
   support levels can in principle be implemented by means of layers
   wrapping the advanced API.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on May 3, 2016.

Copyright Notice

   Copyright (c) 2015 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of



Kline                      Expires May 3, 2016                  [Page 1]

Internet-Draft            MPvD API Requirements             October 2015


   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   2
     1.1.  Requirements Language . . . . . . . . . . . . . . . . . .   3
   2.  High level requirements . . . . . . . . . . . . . . . . . . .   3
     2.1.  Requirements for an API . . . . . . . . . . . . . . . . .   3
     2.2.  Requirements for supporting operating systems . . . . . .   5
       2.2.1.  Source address selection  . . . . . . . . . . . . . .   5
       2.2.2.  Route isolation . . . . . . . . . . . . . . . . . . .   6
       2.2.3.  Automatic PvD metadata marking  . . . . . . . . . . .   6
       2.2.4.  Additional system and library support . . . . . . . .   6
   3.  XXX Conceptual PvDs . . . . . . . . . . . . . . . . . . . . .   7
     3.1.  XXX The 'null' PvD  . . . . . . . . . . . . . . . . . . .   7
     3.2.  XXX The 'loopback' PvD  . . . . . . . . . . . . . . . . .   7
     3.3.  XXX The 'default' PvD . . . . . . . . . . . . . . . . . .   7
   4.  Requirements for new API functionality  . . . . . . . . . . .   8
     4.1.  Learning of PvD availability  . . . . . . . . . . . . . .   8
     4.2.  Learning network configuration information comprising a
           PvD . . . . . . . . . . . . . . . . . . . . . . . . . . .   8
     4.3.  XXX Scoping functionality to a specific PvD . . . . . . .   9
     4.4.  XXX Explicit versus Implicit PvDs . . . . . . . . . . . .   9
     4.5.  Policy restrictions . . . . . . . . . . . . . . . . . . .  10
     4.6.  XXX PvD Programmatic reference implementation
           considerations  . . . . . . . . . . . . . . . . . . . . .  10
   5.  XXX Updated API functions for scoping functionality to a
       specific PvD  . . . . . . . . . . . . . . . . . . . . . . . .  11
     5.1.  XXX DNS resolution  . . . . . . . . . . . . . . . . . . .  12
   6.  Acknowledgements  . . . . . . . . . . . . . . . . . . . . . .  13
   7.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  13
   8.  XXX Security Considerations . . . . . . . . . . . . . . . . .  13
   9.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  14
     9.1.  Normative References  . . . . . . . . . . . . . . . . . .  14
     9.2.  Informative References  . . . . . . . . . . . . . . . . .  14
     9.3.  URIs  . . . . . . . . . . . . . . . . . . . . . . . . . .  15
   Author's Address  . . . . . . . . . . . . . . . . . . . . . . . .  15

1.  Introduction

   RFC 7556 [RFC7556] provides the essential conceptual guidance an API
   designer would need to support use of PvDs.  This document aims to
   capture the requirements for an API that can be used by applications
   that would be considered "advanced", according to section 6.3 [4] of
   RFC 7556 [RFC7556].  The "basic" [5] and "intermediate" [6] API
   support levels can in principle be implemented by means of layers
   wrapping the advanced API.



Kline                      Expires May 3, 2016                  [Page 2]

Internet-Draft            MPvD API Requirements             October 2015


   This document also attempts to make some of the API implementation
   requirements more concrete by discussion and example.

1.1.  Requirements Language

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119 [RFC2119].

2.  High level requirements

   As described in section 2 [7] of RFC 7556 [RFC7556], a Provisioning
   Domain ("PvD") is fundamentally a "consistent set of network
   configuration information."  This includes information like:

   o  the list of participating interfaces

   o  IPv4 and IPv6 addresses

   o  IPv4 and IPv6 routes: both default routes and more specifics (such
      as may be learned via RFC 4191 [RFC4191] Route Information Options
      ("RIOs"))

   o  DNS nameservers, search path, et cetera

   o  HTTP proxy configuration

   and undoubtedly many more configuration elements yet to be specified
   (like metering hints, transmission medium and speed, captive portal
   URL, et cetera).

   This configuration information as whole may not be able to be learned
   atomically, may need to be synthesized from multiple sources
   including administrative provisioning, and cannot be presumed to be
   unchanging over the lifetime of a node's association with a given
   PvD.

   In order for an application to make consistent use [8] of a given
   PvD's network configuration several requirements are placed upon the
   API itself and the host operating system providing the API.

2.1.  Requirements for an API

   At the highest level, the requirements for an API that enables
   applications to make sophisticated use of multiple PvDs amount to
   providing mechanisms by which they can:

   R1  observe accessible PvDs



Kline                      Expires May 3, 2016                  [Page 3]

Internet-Draft            MPvD API Requirements             October 2015


       It MUST be possible for an application to be informed of the set
       of all PvDs it can currently access, and to be informed of
       changes to this set.

   R2  observe configuration elements of an accessible PvD

       It MUST be possible to learn requested configuration information
       of any accessible PvD, and to be informed of any changes to the
       configuration information comprising an accessible PvD.

   R3  scope networking functionality to a specified PvD

       For every existing API function that interacts with the node's
       networking stack, be it at a relatively high level like
       getaddrinfo() [9] or at the level of something like Sockets API's
       sendmsg(), there MUST be a means by which an application can
       specify the PvD within which networking operations are to be
       restricted.

   R4  consistent use of programmatic references to PvDs

       For uniformity and simplicity, every PvD-aware API functional
       element SHOULD use (as return values of function calls, function
       arguments, et cetera) the same programmatic reference for PvDs,
       e.g. a construct containing a PvD identifier [10] or some
       equivalent shorthand reference token (see Section 4.6 for a
       discussion of implementation considerations).

   It is import to note that there is always a provisioning domain
   within which networking functionality is scoped.  For simply-
   connected hosts this may be the implicit PvD [11] created by a single
   networking interface connected to a traditional, shared LAN segment.
   For multihomed hosts the "default provisioning domain" is likely a
   matter of policy, but MAY be a "null" PvD, i.e. one completely devoid
   of networking configuration information (no addresses, no routes, et
   cetera).  See Section 3 for further discussion.

   The utility of such an API (allowing applications to learn of and
   control the scope of networking functionality) suggests that the
   Provisioning Domain is perhaps a more useful operational definition
   for the original IPv6 concept of a "site-local scope" than the ill-
   fated [RFC3879], "ill-defined concept" [12] of a site.  It also
   suggests one possible way by which host operating support for a PvD-
   aware API might be implemented.







Kline                      Expires May 3, 2016                  [Page 4]

Internet-Draft            MPvD API Requirements             October 2015


2.2.  Requirements for supporting operating systems

   The multiple PvD model of host behaviour is perhaps closer to the
   Strong End System Model than the Weak End System Model characterized
   in RFC 1122 [RFC1122] section 3.3.4.2 [13], but owing to its
   recognition of a many-to-many relationship between interfaces and
   PvDs should be considered a unique model unto itself.

   In the PvD-aware End System Model, the "two key requirement issues
   related to multihoming" are restated as:

   a.  A host MAY silently discard an incoming datagram whose
       destination address does not correspond to any PvD associated
       with the physical (or virtual) interface through which it is
       received.

   b.  A host MUST restrict itself to sending (non-source-routed) IP
       datagrams only through the physical (or virtual) interfaces that
       correspond to the PvD associated with the IP source address of
       the datagrams.

   In order to support a PvD-aware application's use of multiple PVDs,
   several additional requirements must be met by the host operating
   system, especially when performing functions on behalf of
   applications or when no direct application intervention is possible,
   as discussed in the following sections.

2.2.1.  Source address selection

   Whenever a source address is to be selected on behalf of an
   application it is essential for consistent use that only source
   addresses belonging to the currently scoped PvD be used a candidate
   set.  (See RFC 6418 [RFC6418] section 3.5 [14] for references to
   issues arising from poor source address selection.)

   For nodes following the PvD-aware End System Model, RFC 6724
   [RFC6724] section 4 [15] is amended as follows:

   R5  The candidate source addresses MUST be restricted to the set of
       unicast addresses associated with the (explicitly or implicitly)
       specified PvD.

       Additionally, source address selection policies from PvDs other
       than the (explicitly or implicitly) specified PvD MUST NOT be
       applied.






Kline                      Expires May 3, 2016                  [Page 5]

Internet-Draft            MPvD API Requirements             October 2015


2.2.2.  Route isolation

   Whenever a routing lookup for destination is to be performed, it is
   essential that only routes belonging to the currently scoped PvD be
   consulted.  Applications and libraries that use the inherent routing
   reachability check (and subsequent source address selection)
   performed during something like the Sockets API connect() call on a
   UDP socket to learn reachability information cheaply cannot function
   correctly otherwise.  RFC 6418 [RFC6418] section 4.2 [16] contains
   more discussion and references to issues arising from insufficiently
   isolated routing information.

   For nodes following the PvD-aware End System Model:

   R6  The set of routes consulted for any routing decision MUST be
       restricted to the routes associated with the (explicitly or
       implicitly) specified PvD.

2.2.3.  Automatic PvD metadata marking

   In many cases, an application can examine a source address or the
   destination address of a received datagram and use that address's
   association with a given PvD to learn, for example, the PvD with
   which an incoming connection may be associated.  It may, however, be
   impossible for an application to make this determination on its own
   if, for example, an incoming TCP connection is destined to a RFC 1918
   [RFC1918] address that happens to be configured in multiple PvDs at
   the same time.  In such circumstances, the supporting operating
   system will need to provide additional assistance.

   For nodes following the PvD-aware End System Model:

   R7  For networking functionality performed on behalf of an
       application, the supporting operating system MUST record and make
       available to the application either (1) all the information the
       application might need to make a PvD evaluation on its own or (2)
       the API's PvD programmatic reference directly.

       A supporting operating system SHOULD record and make available
       the API's PvD programmatic reference; other approaches invite
       ambiguity among applications' interpretation of available
       information.

2.2.4.  Additional system and library support

   Frequently, operating systems have several additional supporting
   libraries and services for more advance networking functionality.
   Using the system's own PvD API, meeting the above requirements, it



Kline                      Expires May 3, 2016                  [Page 6]

Internet-Draft            MPvD API Requirements             October 2015


   should be possible to extend them to provide correct per-PvD
   isolation of information and application support.

3.  XXX Conceptual PvDs

3.1.  XXX The 'null' PvD

   Useful to ensure networking functions fail (and fail quickly) If
   there are no PvDs accessible to a user/group/application, either as a
   matter of policy (insufficient privileges) or as a matter of natural
   circumstance (the node is not connected to any network), the 'null'
   PvD may be a suitable PvD for the API to return to application
   queries or to apply as the PvD of use in the absence of other
   explicitly reference PvDs.

3.2.  XXX The 'loopback' PvD

   - useful to scope networking functions to the node only - has only
   locally assigned addresses and routes specifying local delivery and
   no default routes - MAY have other configuration elements consisting
   of locally accessible services - TODO: ask for help/clarification
   here

3.3.  XXX The 'default' PvD

   PvD-aware system as a whole SHOULD have a notion of currently active
   default PvD

   - makes "basic 6.1" trivial - without this application behaviour will
   be highly system dependent (does the system iterate through PvDs, in
   some order, trying to find a PvD in which a certain op succeeds?) -
   this is the PvD to use for operations for which a PvD must be
   selected and no explicity PvD API has been used - as a matter of
   policy, this MAY be a "null" PvD, effectively requiring all apps to
   be PvD-aware, or "loopback" to permit locally communications only for
   non-PvD-aware apps - SHOULD be a way to communicate changes in the
   default PvD - MUST be able to specify that the default PvD is to be
   used

   For backward compatibility for non-PvD-aware applications, there MUST
   exist a "default PvD", i.e. a PvD within which system functions
   requiring a PvD are to be performed.

   It is expected that most nodes will use a variety of information
   coupled with administrative policy to promote one of a number of
   currently active PvDs to be the default for ease of backward
   compatibility, and to promote another active PvD in its place as
   circumstances change.



Kline                      Expires May 3, 2016                  [Page 7]

Internet-Draft            MPvD API Requirements             October 2015


   TBD: 'PVD_UNSPEC'

4.  Requirements for new API functionality

4.1.  Learning of PvD availability

   R8  A PvD-aware API MUST implement a mechanism whereby an application
       can receive a set of the API's PvD programmatic references
       representing the complete set of PvDs (both explicit [17] and
       implicit [18]) with which the node is currently associated.

   R9  A PvD-aware API implementation SHOULD contain a mechanism
       enabling an application to be notified of changes in the above
       set of actively associated PvDs in a comparatively efficient
       manner (i.e. more efficient than polling).

4.2.  Learning network configuration information comprising a PvD

   R10 A PvD-aware API MUST include a mechanism whereby by an
       application, using the API's PvD programmatic reference, can
       receive elements of the network configuration information that
       comprise a PvD.  At a minimum, this mechanism MUST be capable of
       answering queries for:

       *  the PvD identifier

       *  all participating interfaces

       *  all IPv4 and all non-deprecated IPv6 addresses

       *  all configured DNS nameservers

   A PvD's network configuration information is neither guaranteed to be
   learned atomically nor is it guaranteed to be static.  Addresses,
   routes, and even DNS nameservers and participating interfaces may
   each change over the lifetime of the node's association to a given
   PvD.  Timely notification of such changes may be of particular
   importance to some applications.

   R11 A PvD-aware API implementation SHOULD contain a mechanism
       enabling an application to be notified of changes in the
       networking configuration information comprising a PvD in a
       comparatively efficient manner (i.e. more efficient than
       polling).

   R12 A network configuration query API implementation SHOULD take
       extensibility into account, to support querying for configuration




Kline                      Expires May 3, 2016                  [Page 8]

Internet-Draft            MPvD API Requirements             October 2015


       information not yet conceived of with minimal adverse impact to
       applications.

4.3.  XXX Scoping functionality to a specific PvD

   R13 A PvD-aware API implementation MUST include a mechanism for an
       application to specify the PvD programmatic reference of the PvD
       to which all networking functionality MUST be restricted when not
       otherwise explicitly specified (an application-specific "default
       PvD").

   R14 The API implementation MUST support setting such a "default PvD"
       for an application's entire process (and by extension its child
       processes).  Additionally, the API SHOULD support an application
       setting a "default PvD" at every granularity of "programming
       parallelization", i.e. not only per-process, but also per-thread,
       per-fiber, et cetera.

   R15 For every degree of granularity at which an application may
       specify a "default PvD" there MUST exist a corresponding
       mechanism to retrieve the currently specified implementation-
       specific PvD programmatic reference.

   XXX - useful for being able to start non-PvD-aware apps within a
   single PvD context unbeknownst to them and operate correctly -
   indeed, this could be used as a definition / validation that a PvD
   implementation is correct: non-PvD-aware apps function correctly,
   with no negative impact, in a single PvD without being PvD-aware

4.4.  XXX Explicit versus Implicit PvDs

   - the API used by PvD-aware applications MUST support both implicit
   and explicit PvDs - It SHOULD NOT be necessary for a PvD-aware
   application to distinguish between explicit and implicit PvDs.  Both
   SHOULD be equally accessible and useful via the same API calls.  -
   PvD-aware nodes should provide PvD identifiers for implicit PvDs that
   can be used without application change in the same ways as explicit
   PvDs

   For every element of system functionality that has historically been
   performed in the context of a single, implicit PvD an API extension
   MUST exist allowing the application to specificy that the same
   functionality be performed within the scope of an explicitly
   requested PvD (via identifier or handle).







Kline                      Expires May 3, 2016                  [Page 9]

Internet-Draft            MPvD API Requirements             October 2015


4.5.  Policy restrictions

   This document does not make recommendations about policies governing
   the use of any or all elements of a PvD API, save only to note that
   some restrictions on use may be deemed necessary or appropriate.

   R16 A PvD API implementation MAY implement policy controls whereby
       access to PvD availability information, configuration elements,
       and/or explicit scoping requests is variously permitted or denied
       to certain applications.

4.6.  XXX PvD Programmatic reference implementation considerations

   - node-specific token used to identify an instance of a single
   provisioning domain's configuration data // Not guaranteed to be
   stable across across associations to a PVD.  // // The same PVD may
   have different pvd_handle_t's if, for example, // when reattaching
   later to the same PVD (returning home in the // evening), the same
   PVD may be assigned a different pvd_handle_t.  // // The pvd_handle_t
   must remain valid until a disconnection or // disassociation event
   occurs, after which the pvd_handle_t MUST NOT // be recycled to refer
   to a different PVD so long as there remain // any identifiable
   references to it (e.g. a process or thread still // has this PVD
   index set as its default).  // // Applications explicitly specifying
   PVD indices to PVD-aware // functions are not readily identifiable
   (indeed an application // could progressively walk the PVD index
   space attempting various // function calls without ever having
   received any indication from // the system that a given index was
   valid).  In order to account for // this, PVD indices SHOULD NOT be
   recycled, to the extent possible.  // One acceptable implementation
   approach is to assign every new PVD // context a strictly
   monotonically increasing index, such that any // specific index is
   not reused until the unsigned integer space has // been completely
   exhausted, before restarting again from 1.  // The value
   PVD_HANDLE_UNSPEC is used to indicate no specific PVD.  // //
   Depending on the context it may indicate that the system does not //
   implement support for the Provisioning Domain API, an error, or // a
   signal to "clear" previous PVD index state.  - a given provisioning
   domain MUST NOT be assumed to have the same handle across attaches -
   implementations SHOULD NOT re-use the same handle for the same
   provisioning domain across attaches because: awesome explanation goes
   here.

   Given that PvD identifiers may be of a length or form not easily
   passed around programmatically, API implementions SHOULD consider a
   programmatically simple handle for use with the variety of API calls.
   https://tools.ietf.org/html/rfc7556#section-2.4




Kline                      Expires May 3, 2016                 [Page 10]

Internet-Draft            MPvD API Requirements             October 2015


   API implementations that use short handles to reference PvD
   information (identifiers, configuration information) SHOULD consider
   varying the handle used for a specific PvD with each separate attach,
   e.g. a 3GPP connection to "apn.carrier.example" might have handle 100
   for the first attach after boot, and 101 for the next attach after
   going into and coming out of "airplane mode".  Because there is no
   guarantee that the configuration information, like delegated prefixes
   and configured IP addresses, will be the same with every successful
   attachment to the same PvD, changing the handle accordingly can help
   to disabuse application writers of erroneous notions of caching PvD
   configuration information from one attachment instance to another.

5.  XXX Updated API functions for scoping functionality to a specific
    PvD

   - everything that implicitly used a single PvD, e.g. when a single
   interface was connected to a single PvD network, SHOULD be extended
   to be invoked with a PvD argument

   In order to ease porting of non-PVD-aware applications as well as
   support non-PVD-aware applications in accordance with the principle
   of least surprise it is recommended that the following functionality
   be added to existing system networking APIs.

   sockets API - setsockopt() / getsockopt() - IP_RECVPVD / IPV6_RECVPVD
   - recvmsg() should include indication of PVD to which the packet
   arrived - IP_PVD / IPV6_PVD - source address selection and applicable
   routing table is restricted to the specified PvD - if a source
   address has already been selected from one PvD, transmitting via
   another PvD is NOT RECOMMENDED (but of course possible) -
   PVD_UNSPECIFIED - no PvD explicitly requested - also used to clear a
   process or thread default and revert to system default - for PF_INET
   / PF_INET6 sockets - socket() - if a process-default or thread-
   default PvD has been set, the returned file descriptor must be
   "bound" to the PvD - i.e. as if setsockopt(SOL_IPV6, IPV6_PVD, ...)
   had been called - otherwise, the file descriptor defaults to
   PVD_UNSPECIFIED - bind() - if a PvD is specified and address is
   unspecified, it is RECOMMENDED source address selection be restricted
   to this PVD - else if a PvD is specified and address is not
   unspecified, EADDRNOTAVAIL might be returned - else best effort /
   system-specific policies apply - listen() - if the file descriptor is
   already bound to a PvD, only traffic to one of the PvD's addresses
   should cause the file descriptor to become readable - other traffic
   should receive an ICMP error - accept() - returned file descriptors
   should be bound to the PvD of: - the listening socket, if it was not
   bound to PVD_UNSPECIFIED - the PvD of the destination address on the
   system - connect() - bind() discussion applies for source address
   selection - EHOSTUNREACH / ENETUNREACH might be returned sendmsg() /



Kline                      Expires May 3, 2016                 [Page 11]

Internet-Draft            MPvD API Requirements             October 2015


   recvmsg() cmsg semantics - setsockopt() / getsockopt() options apply
   - IP_RECVPVD / IPV6_RECVPV6 - IP_PVD / IPV6_PVD

   - sockets examples: /* * getsockopt()/setsockopt() * * The header
   file sys/socket.h SHALL define SO_PVD_HANDLE in supporting *
   implementations, for use with getsockopt/setsockopt and the
   SOL_SOCKET * level.  The option_value shall be understood to be a
   pointer to a * pvd_handle_t and the option_len is required to be
   sizeof(pvd_handle_t).  * * Setting the SO_PVD_HANDLE option
   constrains all operations on the * specified socket to function only
   within the specified PVD currently * described by pvd_handle_t.  If
   the pvd_handle_t argument has the value * PVD_HANDLE then the
   operating-system policy-defined default is * to be used (see net/
   pvd.h).  */ /* * recvmsg()/sendmsg() * * The same SO_PVD_HANDLE
   defined above shall be used as the cmsg_type in * conjunction with
   the SOL_SOCKET cmsg_level to specify struct cmsghdr * entries for use
   with recvmsg() and sendmsg().  These have the same * effect described
   above though applicability is limited to the immediate *
   sendmsg()/recvmsg() invocaton and not for the lifetime the socket
   file * descriptor.  * * In certain situations it may be difficult or
   impossible for an operating * system to determing the correct
   pvd_handle_t for incoming messages (e.g.  * when there are multiple
   provisioning domains in a single interface and * the system is unable
   to determine which PVD should be associated with * the source of the
   message.  In such cases, the value returned in the * cmsg_data field
   MAY be PVD_HANDLE.  This is not an error, but * rather an
   underspecified situation.  */ /* * accept() * * If a listening socket
   is associated with a single PVD, e.g. via a prior * call to
   pvd_set_*_default(...) or setsockopt(SOL_SOCKET, SO_PVD_HANDLE, ...)
   * then traffic arriving from other provisioning domains MUST NOT
   cause a new * connection.  * * Furthermore, whether or not a
   listening socket has a specified PVD, the * specified PVD MUST be set
   for the accept()ed file descriptor.  Note that * in certain
   situations (e.g. listening socket using PVD_HANDLE_UNSPEC and *
   multiple PVDs on a single interface with insufficient data to map *
   incoming traffic to specific PVDs), the specified PVD MAY be *
   PVD_HANDLE_UNSPEC.  This is not an error, but rather an
   underspecified * situation.  * * More broadly, operating systems
   SHOULD, wherever possible, implement * this style of incoming
   specified pvd_handle_t reflection for other protocols * with similar
   accept()-style semantics.  */

5.1.  XXX DNS resolution

   For nodes following the PvD-aware End System Model:

   R17 A PVD-aware API MUST make it possible for an application to
       perform normal name resolution constrained to the name resolution



Kline                      Expires May 3, 2016                 [Page 12]

Internet-Draft            MPvD API Requirements             October 2015


       configuration within a specified PVD.  /* * getaddrinfo w/
       pvd_handle_t argument */ /* * getnameinfo w/ pvd_handle_t
       argument */ Implementations of RFC 3493 [RFC3493] section 6.1
       [19] getaddrinfo() - getaddrinfo() and AI_ADDRCONFIG -
       RFC3493#section-6.1 "...shall be returned only if an IPv4/v6
       address is configured on the local system..." -> "... within the
       requested PvD"

6.  Acknowledgements

   The core concepts presented in this document were developed during
   the Android multinetworking effort by Lorenzo Colitti, Robert
   Greenwalt, Paul Jensen, and Sreeram Ramachandran.

   Additional thanks to the coffee shops of Tokyo.

7.  IANA Considerations

   This memo includes no request to IANA.

8.  XXX Security Considerations

   Consider whether 7556 section 8 should be referenced.  Possibly not,
   since those seem to be focused on external PvD-altering threats.

   The major new security impact of a PvD-aware API is that it becomes
   much simpler (by design) to write a functional application to create
   a bridging data path between two PvDs that would not have otherwise
   necessarily have been so easily connected.

   For some operating systems, existing APIs already make this bridging
   possible, though some functionality like DNS resolution may have been
   difficult to implement.  Indeed, the very aim of an MPvD API is to
   make implementing a PvD-aware application simple and to make its
   functioning more "correct" ("first class" support for such
   functionality).

   Operating system implementations have several points of potential
   policy control including:

   o  use of certain PvDs MAY be restricted by policy (e.g. only
      approved users, groups, or applications might be permitted
      access), and/or

   o  use of more than one PvD (or the MPvD API itself) MAY be similarly
      restricted.





Kline                      Expires May 3, 2016                 [Page 13]

Internet-Draft            MPvD API Requirements             October 2015


9.  References

9.1.  Normative References

   [RFC1122]  Braden, R., Ed., "Requirements for Internet Hosts -
              Communication Layers", STD 3, RFC 1122, DOI 10.17487/
              RFC1122, October 1989,
              <http://www.rfc-editor.org/info/rfc1122>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.

   [RFC3493]  Gilligan, R., Thomson, S., Bound, J., McCann, J., and W.
              Stevens, "Basic Socket Interface Extensions for IPv6", RFC
              3493, DOI 10.17487/RFC3493, February 2003,
              <http://www.rfc-editor.org/info/rfc3493>.

   [RFC6724]  Thaler, D., Ed., Draves, R., Matsumoto, A., and T. Chown,
              "Default Address Selection for Internet Protocol Version 6
              (IPv6)", RFC 6724, DOI 10.17487/RFC6724, September 2012,
              <http://www.rfc-editor.org/info/rfc6724>.

   [RFC7556]  Anipko, D., Ed., "Multiple Provisioning Domain
              Architecture", RFC 7556, DOI 10.17487/RFC7556, June 2015,
              <http://www.rfc-editor.org/info/rfc7556>.

9.2.  Informative References

   [RFC1918]  Rekhter, Y., Moskowitz, B., Karrenberg, D., de Groot, G.,
              and E. Lear, "Address Allocation for Private Internets",
              BCP 5, RFC 1918, DOI 10.17487/RFC1918, February 1996,
              <http://www.rfc-editor.org/info/rfc1918>.

   [RFC3879]  Huitema, C. and B. Carpenter, "Deprecating Site Local
              Addresses", RFC 3879, DOI 10.17487/RFC3879, September
              2004, <http://www.rfc-editor.org/info/rfc3879>.

   [RFC4191]  Draves, R. and D. Thaler, "Default Router Preferences and
              More-Specific Routes", RFC 4191, DOI 10.17487/RFC4191,
              November 2005, <http://www.rfc-editor.org/info/rfc4191>.

   [RFC6418]  Blanchet, M. and P. Seite, "Multiple Interfaces and
              Provisioning Domains Problem Statement", RFC 6418, DOI 10
              .17487/RFC6418, November 2011,
              <http://www.rfc-editor.org/info/rfc6418>.






Kline                      Expires May 3, 2016                 [Page 14]

Internet-Draft            MPvD API Requirements             October 2015


9.3.  URIs

   [1] https://tools.ietf.org/html/rfc7556#section-6.3

   [2] https://tools.ietf.org/html/rfc7556#section-6.1

   [3] https://tools.ietf.org/html/rfc7556#section-6.2

   [4] https://tools.ietf.org/html/rfc7556#section-2

   [5] https://tools.ietf.org/html/rfc7556#section-5.2

   [6] https://tools.ietf.org/html/rfc3493#section-6.1

   [7] https://tools.ietf.org/html/draft-ietf-mif-mpvd-id

   [8] https://tools.ietf.org/html/rfc7556#section-2.2

   [9] https://tools.ietf.org/html/rfc3879#section-2.5

   [10] https://tools.ietf.org/html/rfc1122#section 3.3.4.2

   [11] https://tools.ietf.org/html/rfc6418#section-3.5

   [12] https://tools.ietf.org/html/rfc6724#section-4

   [13] https://tools.ietf.org/html/rfc6418#section-4.2

   [14] https://tools.ietf.org/html/rfc7556#section-2.1

   [15] https://tools.ietf.org/html/rfc7556#section-2.2

   [16] https://tools.ietf.org/html/rfc3493#section-6.1

Author's Address

   Erik Kline
   Google Japan KK
   6-10-1 Roppongi
   Mori Tower, 44th floor
   Minato, Tokyo  106-6126
   JP

   Email: ek@google.com







Kline                      Expires May 3, 2016                 [Page 15]
