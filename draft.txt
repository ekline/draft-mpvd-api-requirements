



Internet Engineering Task Force                            E. Kline, Ed.
Internet-Draft                                           Google Japan KK
Intended status: Informational                        September 29, 2015
Expires: April 01, 2016


       Multiple Provisioning Domains Application API Requirements
                 draft-kline-mif-pvd-application-api-00

Abstract

   Insert an abstract: MANDATORY.  This template is for creating an
   Internet Draft.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on April 01, 2016.

Copyright Notice

   Copyright (c) 2015 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.






Kline                    Expires April 01, 2016                 [Page 1]

Internet-Draft            MPVD Application API            September 2015


Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   2
     1.1.  Requirements Language . . . . . . . . . . . . . . . . . .   3
   2.  TL;DR . . . . . . . . . . . . . . . . . . . . . . . . . . . .   3
     2.1.  Requirements for a mPvD API implementation  . . . . . . .   4
     2.2.  Recommendations for a mPvD API implementation . . . . . .   4
   3.  Discussion  . . . . . . . . . . . . . . . . . . . . . . . . .   4
   4.  Requirements for new API functionality  . . . . . . . . . . .   5
   5.  Requirements for updates to existing API functionality  . . .   5
   6.  a . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   5
   7.  b . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   5
   8.  Host Operating System Requirements  . . . . . . . . . . . . .   6
   9.  c . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   6
   10. New API Definitions . . . . . . . . . . . . . . . . . . . . .   6
   11. Extensions for Existing Sockets API Functions . . . . . . . .   6
   12. Acknowledgements  . . . . . . . . . . . . . . . . . . . . . .   6
   13. IANA Considerations . . . . . . . . . . . . . . . . . . . . .   6
   14. Security Considerations . . . . . . . . . . . . . . . . . . .   6
   15. References  . . . . . . . . . . . . . . . . . . . . . . . . .   7
     15.1.  Normative References . . . . . . . . . . . . . . . . . .   7
     15.2.  Informative References . . . . . . . . . . . . . . . . .   7
   Appendix A.  Comparison with Android implementation . . . . . . .   7
   Author's Address  . . . . . . . . . . . . . . . . . . . . . . . .   7

1.  Introduction

   RFC 7556 provides all the essential guidance an API designer would
   need to support use of PvDs.  This document aims to make some of the
   implications more concrete by discussion and example.

   All system functionality that has historically been performed in the
   context of a single, implicit PvD must be updated to support the same
   operations on an explicitly requested PvD.

   For backward compatibility for non-PvD-aware applications, there MUST
   exist a "default PvD", i.e. a PvD within which system functions
   requiring a PvD are to be performed.

   Such a PvD MAY be a "null" or "empty" PvD: one in which no addresses
   or routes of any address family are configured and devoid of
   configuration information of any kind.  A system for which he default
   PvD was such a "null" PvD would effectively require all applications
   to be fully PvD-aware in order to function.







Kline                    Expires April 01, 2016                 [Page 2]

Internet-Draft            MPVD Application API            September 2015


   It is expected that most nodes will use a variety of information and
   administrative policy to promote one of a number of currently active
   PvDs to be the default for ease of backward compatibility, and to
   promote another active PvD in its place as circumstances change.

1.1.  Requirements Language

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119 [RFC2119].

2.  TL;DR

   R1  An API call MUST exist whereby an application can learn the
       identifiers, or short handles, of all PvDs active on the system
       at the time.

   R2  An mPvD API implementation MUST include a mechanism whereby an
       application can learn of/be notified of: the arrival of new PvDs
       or the anticipated removal of a PvD.  Actual removal of a PvD can
       be learned by observing any blocking PvD API operation for errors
       indicating the loss of the PvD (e.g. a socket read() returning
       ENONET).

   R3  API implementations that use short handles to reference PvD
       information (identifiers, configuration information) SHOULD
       consider varying the handle used for a specific PvD with each
       separate attach, e.g. a 3GPP connection to "apn.carrier.example"
       might have handle 100 for the first attach after boot, and 101
       for the next attach after going into and coming out of "airplane
       mode".  Because there is no guarantee that the configuration
       information, like delegated prefixes and configured IP addresses,
       will be the same with every successful attachment to the same
       PvD, changing the handle accordingly can help to disabuse
       application writers of erroneous notions of caching PvD
       configuration information from one attachment instance to
       another.

   R4  There MUST be an API call which, when passed a PvD identifier or
       short handle, returns elements of configuration information
       specific to that PvD.










Kline                    Expires April 01, 2016                 [Page 3]

Internet-Draft            MPVD Application API            September 2015


   R5  This API MUST be extenible, as PvD information is not guaranteed
       to be learned atomically nor is it guaranteed to be static.
       Furthermore, this API needs to be extensible in order to
       accomodate requesting new configuration information not yet
       conceived of at this time, e.g. a new FOO protocol is used within
       a given PvD and it's important for applications to learn that
       they need to use the proxy BAR for best performance.

   R6  An mPvD API implementation MUST include a mechanism whereby an
       application can learn of changes to the configuration information
       of a given PvD, e.g. a new temporary address has been formed, a
       new secondary DNS server has replaced the previous secondary, et
       cetera.

   R7  For every element of system functionality that has historically
       been performed in the context of a single, implicit PvD an API
       extension MUST exist allowing the application to specificy that
       the same functionality be performed within the scope of an
       explicitly requested PvD (via identifier or handle).

2.1.  Requirements for a mPvD API implementation

2.2.  Recommendations for a mPvD API implementation

3.  Discussion

   Two major categories of PvD application API requirements: - learning
   about PvDs - existence and changes in availability - configuration
   data contained within a PvD ID and changes of configuration
   information - selection of a PvD to scope various operations: -
   selection of configuration information - selection of source
   addresses - selection of routing information (consistent use) https:/
   /tools.ietf.org/html/rfc7556#section-5.2

   High-level API requirements are: - it must be possible to learn of
   pvds coming and going - it should be possible to learn pvd
   configuration information and updates - everything done today with an
   implicit pvd assumed must be doable with an explicit pvd

   The rest of this document is concerned with: - identifying new system
   requirements - identifying some existing uses of implicit pvds that
   will need to be updated to support explicit pvds









Kline                    Expires April 01, 2016                 [Page 4]

Internet-Draft            MPVD Application API            September 2015


4.  Requirements for new API functionality

   API implementors SHOULD provide a mechanism for an application to set
   its default PvD, i.e. the PvD to be used by API calls made without
   reference to an explicit PvD.

   API implementors SHOULD provide a mechanism for an application to set
   its default PvD at the granularity of "programming parallelization":
   per-process, per-thread, per-fiber, et cetera.

   Given that PvD identifiers may be of a length or form not easily
   passed around programmatically, API implementions SHOULD consider a
   programmatically simple handle for use with the variety of API calls.
   https://tools.ietf.org/html/rfc7556#section-2.4

   An mPvD API implementation SHOULD consider implementing policy
   controls

   o  get currently available PvDs

   o  get current default PvD, if system supports concept of default

   o  get notified of changes to the set of available PvDs: new, change
      in default

   o  set default PvD per process and per thread

   o  all config info, learn mapping between interfaces and PvD IDs/
      handles, must be extensible

   o  ...

5.  Requirements for updates to existing API functionality

   In order to ease porting of non-PVD-aware applications as well as
   support non-PVD-aware applications in accordance with the principle
   of least surprise it is recommended that the following functionality
   be added to existing system networking APIs.

6.  a

7.  b









Kline                    Expires April 01, 2016                 [Page 5]

Internet-Draft            MPVD Application API            September 2015


   ## 1 PvD . RFC7556 section 2 . "A consistent set of network
   configuration information..." - includes: - participating interfaces
   - addresses - routes (default routes and more specifics) - but also
   RIO -type information - DNS servers and search path - HTTP proxy -
   yet to be specified: metering, medium, captive portal URL, ...  - not
   learned atomically - not static

8.  Host Operating System Requirements

   In order to support the application's use of multiple PVDs, several
   requirements must be fulfilled by the part of the host operating
   system authorized to perform the required functions.

9.  c

10.  New API Definitions

11.  Extensions for Existing Sockets API Functions

12.  Acknowledgements

   The core concepts captured in this document were developed during the
   Android multinetworking effort by Lorenzo Colitti, Robert Greenwalt,
   Paul Jensen, and Sreeram Ramachandran.

   Additional thanks to the coffee shops of Tokyo.

13.  IANA Considerations

   This memo includes no request to IANA.

14.  Security Considerations

   The major new security impact of an mPvD API is that it becomes much
   simpler (by design) to write a functional application to create a
   bridging data path between two PvDs that would not have otherwise
   been directly connected.

   For some operating systems, existing APIs already make this bridging
   possible, though some functionality like DNS resolution may have been
   difficult to implement.  Indeed, the very aim of an mPvD API is to
   make implementing a PvD-aware application simple and to make its
   functioning more "correct" ("first class" support for such
   functionality).

   Operating system implementations have several points of potential
   policy control including:




Kline                    Expires April 01, 2016                 [Page 6]

Internet-Draft            MPVD Application API            September 2015


   o  use of certain PvDs MAY be restricted by policy (e.g. only
      approved users, groups, or individual applications might be
      granted access), and/or

   o  use of more than one PvD (or the mPvD API itself) MAY be
      restricted by policy (e.g. only approved users, groups, or
      individual applications might be granted access).

15.  References

15.1.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.

   [min_ref]  authSurName, authInitials., "Minimal Reference", 2006.

15.2.  Informative References

   [DOMINATION]
              Mad Dominators, Inc., "Ultimate Plan for Taking Over the
              World", 1984, <http://www.example.com/dominator.html>.

   [I-D.narten-iana-considerations-rfc2434bis]
              Narten, T. and H. Alvestrand, "Guidelines for Writing an
              IANA Considerations Section in RFCs", draft-narten-iana-
              considerations-rfc2434bis-09 (work in progress), March
              2008.

   [RFC2629]  Rose, M., "Writing I-Ds and RFCs using XML", RFC 2629,
              June 1999.

   [RFC3552]  Rescorla, E. and B. Korver, "Guidelines for Writing RFC
              Text on Security Considerations", BCP 72, RFC 3552, July
              2003.

Appendix A.  Comparison with Android implementation

   This becomes an Appendix.

Author's Address










Kline                    Expires April 01, 2016                 [Page 7]

Internet-Draft            MPVD Application API            September 2015


   Erik Kline (editor)
   Google Japan KK
   Roppongi 6-10-1
   Mori Tower, 26th floor
   Minato, Tokyo  106-6128
   JP

   Email: ek@google.com











































Kline                    Expires April 01, 2016                 [Page 8]
