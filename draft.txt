



Internet Engineering Task Force                                 E. Kline
Internet-Draft                                           Google Japan KK
Intended status: Informational                           October 5, 2015
Expires: April 7, 2016


             Multiple Provisioning Domains API Requirements
                 draft-kline-mif-pvd-application-api-00

Abstract

   Insert an abstract: MANDATORY.  This template is for creating an
   Internet Draft.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on April 7, 2016.

Copyright Notice

   Copyright (c) 2015 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.






Kline                     Expires April 7, 2016                 [Page 1]

Internet-Draft                  MPvD API                    October 2015


Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   2
     1.1.  Requirements Language . . . . . . . . . . . . . . . . . .   3
   2.  b . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   3
   3.  High level requirements . . . . . . . . . . . . . . . . . . .   3
     3.1.  Functional requirements for an API  . . . . . . . . . . .   3
     3.2.  Functional requirements for a PvD-aware operating system    4
   4.  Conceptual PvDs . . . . . . . . . . . . . . . . . . . . . . .   4
     4.1.  The 'null' PvD  . . . . . . . . . . . . . . . . . . . . .   4
     4.2.  The 'loopback' PvD  . . . . . . . . . . . . . . . . . . .   4
     4.3.  The 'default' PvD . . . . . . . . . . . . . . . . . . . .   5
   5.  New API functions for learning about PvDs . . . . . . . . . .   5
   6.  New API functions for scoping functionality to a specific PvD   5
   7.  Updated API functions for scoping functionality to a specific
       PvD . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   7
   8.  TL;DR . . . . . . . . . . . . . . . . . . . . . . . . . . . .  10
   9.  Requirements for new API functionality  . . . . . . . . . . .  11
   10. Acknowledgements  . . . . . . . . . . . . . . . . . . . . . .  11
   11. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  11
   12. Security Considerations . . . . . . . . . . . . . . . . . . .  11
   13. References  . . . . . . . . . . . . . . . . . . . . . . . . .  12
     13.1.  Normative References . . . . . . . . . . . . . . . . . .  12
     13.2.  Informative References . . . . . . . . . . . . . . . . .  12
   Author's Address  . . . . . . . . . . . . . . . . . . . . . . . .  12

1.  Introduction

   RFC 7556 provides all the essential guidance an API designer would
   need to support use of PvDs.  This document aims to make some of the
   implications more concrete by discussion and example.

   All system functionality that has historically been performed in the
   context of a single, implicit PvD must be updated to support the same
   operations on an explicitly requested PvD.

   For backward compatibility for non-PvD-aware applications, there MUST
   exist a "default PvD", i.e. a PvD within which system functions
   requiring a PvD are to be performed.

   Such a PvD MAY be a "null" or "empty" PvD: one in which no addresses
   or routes of any address family are configured and devoid of
   configuration information of any kind.  A system for which he default
   PvD was such a "null" PvD would effectively require all applications
   to be fully PvD-aware in order to function.

   It is expected that most nodes will use a variety of information and
   administrative policy to promote one of a number of currently active



Kline                     Expires April 7, 2016                 [Page 2]

Internet-Draft                  MPvD API                    October 2015


   PvDs to be the default for ease of backward compatibility, and to
   promote another active PvD in its place as circumstances change.

1.1.  Requirements Language

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119 [RFC2119].

2.  b

   ## 1 PvD . RFC7556 section 2 . "A consistent set of network
   configuration information..." - includes: - participating interfaces
   - addresses - routes (default routes and more specifics) - but also
   RIO -type information - DNS servers and search path - HTTP proxy -
   yet to be specified: metering, medium, captive portal URL, ...  - not
   learned atomically - not static

3.  High level requirements

   High-level API requirements are: - it must be possible to learn of
   pvds coming and going - it should be possible to learn pvd
   configuration information and updates - everything done today with an
   implicit pvd assumed must be doable with an explicit pvd

   The rest of this document is concerned with: - identifying new system
   requirements - identifying some existing uses of implicit pvds that
   will need to be updated to support explicit pvds

3.1.  Functional requirements for an API

   Two major categories of PvD application API requirements: - learning
   about PvDs - existence and changes in availability - configuration
   data contained within a PvD ID and changes of configuration
   information - selection of a PvD to scope various operations: -
   selection of configuration information - selection of source
   addresses - selection of routing information (consistent use)
   https://tools.ietf.org/html/rfc7556#section-5.2

   At a high level, the functional requirements of a multiple
   provisioning domain API ("MPvD API") are:

   1.  learn about the availability of PvDs

   2.  learn about the configuration contents of those PvDs

   3.  allow the application to specify that certain functionality
       should be executed within the scope of a particular PvD



Kline                     Expires April 7, 2016                 [Page 3]

Internet-Draft                  MPvD API                    October 2015


3.2.  Functional requirements for a PvD-aware operating system

   In order to support the application's use of multiple PVDs, several
   requirements must be fulfilled by the part of the host operating
   system authorized to perform the required functions.  ## 5 source
   address and routing selection - if a PvD has been specified: - it is
   RECOMMENDED that source address selection be restricted to PvD
   addresses - update RFC6274#section-4 - it is important to return
   errors - might have two PvDs active: one IPv4-only and one IPv6-only
   - ENONET, EPROTONOSUPPORT, EADDRNOTAVAIL, EHOSTUNREACH, ...  -
   destination reachability: - userspace libraries often use connect()
   tricks to obtain source addresses for sorting - this MUST use the
   routing configuration of the desired PvD - getaddrinfo() and
   AI_ADDRCONFIG - RFC3493#section-6.1 "...shall be returned only if an
   IPv4/v6 address is configured on the local system..." -> "... within
   the requested PvD"

   - more like a strong host model, but one which scopes operations to
   PvDs not interfaces (include weak/strong and m:n pvd:intf references)
   - http://tools.ietf.org/html/rfc1122 section 3.3.4.2: Strong/Weak ES
   model - PvD IDs could be thought of as site-local scopes - required
   support includes: - route isolation - address isolation, update to
   RFC6724 section 4 - actions peformed by the system must set PvD scope
   automatically, even for non-PvD apps: - TCP accept() - incoming
   datagrams to a UDP server - necessary for any API to provide
   consistent and correct behaviour

4.  Conceptual PvDs

4.1.  The 'null' PvD

   Useful to ensure networking functions fail (and fail quickly) If
   there are no PvDs accessible to a user/group/application, either as a
   matter of policy (insufficient privileges) or as a matter of natural
   circumstance (the node is not connected to any network), the 'null'
   PvD may be a suitable PvD for the API to return to application
   queries or to apply as the PvD of use in the absence of other
   explicitly reference PvDs.

4.2.  The 'loopback' PvD

   - useful to scope networking functions to the node only - has only
   locally assigned addresses and routes specifying local delivery and
   no default routes - MAY have other configuration elements consisting
   of locally accessible services - TODO: ask for help/clarification
   here





Kline                     Expires April 7, 2016                 [Page 4]

Internet-Draft                  MPvD API                    October 2015


4.3.  The 'default' PvD

   PvD-aware system as a whole SHOULD have a notion of currently active
   default PvD

   - without this application behaviour will be highly system dependent
   (does the system iterate through PvDs, in some order, trying to find
   a PvD in which a certain op succeeds?) - this is the PvD to use for
   operations for which a PvD must be selected and no explicity PvD API
   has been used - as a matter of policy, this MAY be a "null" PvD,
   effectively requiring all apps to be PvD-aware, or "loopback" to
   permit locally communications only for non-PvD-aware apps - SHOULD be
   a way to communicate changes in the default PvD - MUST be able to
   specify that the default PvD is to be used

5.  New API functions for learning about PvDs

   - MUST existence (subject to policy) - both implicit and explicit
   PvDs must also be included in the API response - PvD-aware
   applications need to be able to specify that some functionality
   should be scoped to an implicit PvD - updates to availability -
   SHOULD new - SHOULD configuration changes (app may also learn via
   errors) - MAY going away (useful) - MAY gone (app may also learn via
   errors) - configuration - SHOULD be an API to get configuration
   information for a specific PvD - such an API MUST be easily
   extensible to support configuration information not yet considered
   Reason to be extensible: - methods to get attributes of a PVD, like
   whether it is comprised of a mobile link versus wifi/ethernet,
   whether there is some metering/charging associated with traffic sent/
   received via this PVD or not, etc.  The same PvD may arrive on
   another interface (3GPP interface and WLAN -- find 3gpp spec
   reference).  This API MUST be extenible, as PvD information is not
   guaranteed to be learned atomically nor is it guaranteed to be
   static.  Furthermore, this API needs to be extensible in order to
   accomodate requesting new configuration information not yet conceived
   of at this time, e.g. a new FOO protocol is used within a given PvD
   and it's important for applications to learn that they need to use
   the proxy BAR for best performance.

6.  New API functions for scoping functionality to a specific PvD

   - apps SHOULD be able to specify which PvD is to be used for network-
   related functionality at the granularity of programming parallelism:
   - per-process (and child processes) - per-thread - per-fiber - useful
   for being able to start non-PvD-aware apps within a single PvD
   context unbeknownst to them and operate correctly - indeed, this
   could be used as a definition / validation that a PvD implemention is
   correct: non-PvD-aware apps function correctly, with no negative



Kline                     Expires April 7, 2016                 [Page 5]

Internet-Draft                  MPvD API                    October 2015


   impact, in a single PvD without being PvD-aware - also per
   application control (e.g. process groups)




// Not guaranteed to be stable across across associations to a PVD.
//
// The same PVD may have different pvd_handle_t's if, for example,
// when reattaching later to the same PVD (returning home in the
// evening), the same PVD may be assigned a different pvd_handle_t.
//
// The pvd_handle_t must remain valid until a disconnection or
// disassociation event occurs, after which the pvd_handle_t MUST NOT
// be recycled to refer to a different PVD so long as there remain
// any identifiable references to it (e.g. a process or thread still
// has this PVD index set as its default).
//
// Applications explicitly specifying PVD indices to PVD-aware
// functions are not readily identifiable (indeed an application
// could progressively walk the PVD index space attempting various
// function calls without ever having received any indication from
// the system that a given index was valid).  In order to account for
// this, PVD indices SHOULD NOT be recycled, to the extent possible.
// One acceptable implementation approach is to assign every new PVD
// context a strictly monotically increasing index, such that any
// specific index is not reused until the unsigned integer space has
// been completely exhausted, before restarting again from 1.
typedef unsigned int pvd_handle_t;

// The value PVD_HANDLE_UNSPEC is used to indicate no specific PVD.
//
// Depending on the context it may indicate that the system does not
// implement support for the Provisioning Domain API, an error, or
// a signal to "clear" previous PVD index state.
#define PVD_HANDLE_UNSPEC ((pvd_handle_t)0)

// Retrieve the current "default" PVD.  If the return type is
// PVD_HANDLE_INVALID there may be no PVD accessible to this process
// at this time or no system support for this API.
//
// These values are used by PVD-aware function calls when a PVD index
// is not explicitly specified.
pvd_handle_t pvd_system_default();

// Same as above, but operates at a per-process level.  If no
// process-specific default has been set this MUST return the value
// of a call to pvd_current_system_default().



Kline                     Expires April 7, 2016                 [Page 6]

Internet-Draft                  MPvD API                    October 2015


pvd_handle_t pvd_process_default();

// Same as above, but operates at a per-thread level.  If no
// thread-specific default has been set this MUST return the value
// of a call to pvd_current_process_default().
pvd_handle_t pvd_thread_default();

int pvd_set_process_default(pvd_handle_t);  // 0 or -1 && errno = EFOO
int pvd_set_thread_default(pvd_handle_t);  // 0 or -1 && errno = EFOO

// Any function that is not easily extended to support a pvd_handle_t
// argument, but for which the underlying operating system understands
// the process-global or per-thread pvd_index can be wrapped to create
// a PVD-aware variant like so:
//
// return_type pvd_functioname(pvd_handle_t pvdix, regular arguments...) {
//     pvd_handle_t saved = pvd_thread_default();
//     if (pvd_set_thread_default(pvdix) != 0) {
//         // handle error
//         return error_indicator_value;
//     }
//     return_type result = functionname(regular arguments...);
//     pvd_set_thread_default(saved);  // Should error-check
//     return result;
// }



7.  Updated API functions for scoping functionality to a specific PvD

   - everything that implicitly used a single PvD, e.g. when a single
   interface was connected to a single PvD network, SHOULD be extended
   to be invoked with a PvD argument

   In order to ease porting of non-PVD-aware applications as well as
   support non-PVD-aware applications in accordance with the principle
   of least surprise it is recommended that the following functionality
   be added to existing system networking APIs.

   sockets API - setsockopt() / getsockopt() - IP_RECVPVD / IPV6_RECVPVD
   - recvmsg() should include indication of PVD to which the packet
   arrived - IP_PVD / IPV6_PVD - source address selection and applicable
   routing table is restricted to the specified PvD - if a source
   address has already been selected from one PvD, transmitting via
   another PvD is NOT RECOMMENDED (but of course possible) -
   PVD_UNSPECIFIED - no PvD explicitly requested - also used to clear a
   process or thread default and revert to system default - for PF_INET
   / PF_INET6 sockets - socket() - if a process-default or thread-



Kline                     Expires April 7, 2016                 [Page 7]

Internet-Draft                  MPvD API                    October 2015


   default PvD has been set, the returned file descriptor must be
   "bound" to the PvD - i.e. as if setsockopt(SOL_IPV6, IPV6_PVD, ...)
   had been called - otherwise, the file descriptor defaults to
   PVD_UNSPECIFIED - bind() - if a PvD is specified and address is
   unspecified, it is RECOMMENDED source address selection be restricted
   to this PVD - else if a PvD is specified and address is not
   unspecified, EADDRNOTAVAIL might be returned - else best effort /
   system-specific policies apply - listen() - if the file descriptor is
   already bound to a PvD, only traffic to one of the PvD's addresses
   should cause the file descriptor to become readable - other traffic
   should receive an ICMP error - accept() - returned file descriptors
   should be bound to the PvD of: - the listening socket, if it was not
   bound to PVD_UNSPECIFIED - the PvD of the destination address on the
   system - connect() - bind() discussion applies for source address
   selection - EHOSTUNREACH / ENETUNREACH might be returned sendmsg() /
   recvmsg() cmsg semantics - setsockopt() / getsockopt() options apply
   - IP_RECVPVD / IPV6_RECVPV6 - IP_PVD / IPV6_PVD - source address
   selection discussion applies for IP_PVD / IPV6_PVD - some
   combinations just may not work - some may require privileges to even
   attempt

   - sockets examples:



/*
 * getsockopt()/setsockopt()
 *
 * The header file <sys/socket.h> SHALL define SO_PVD_HANDLE in supporting
 * implementations, for use with getsockopt/setsockopt and the SOL_SOCKET
 * level.  The option_value shall be understood to be a pointer to a
 * pvd_handle_t and the option_len is required to be sizeof(pvd_handle_t).
 *
 * Setting the SO_PVD_HANDLE option constrains all operations on the
 * specified socket to function only within the specified PVD currently
 * described by pvd_handle_t.  If the pvd_handle_t argument has the value
 * PVD_HANDLE then the operating-system policy-defined default is
 * to be used (see <net/pvd.h>).
 */
#define SO_PVD_HANDLE  some_implementation_specific_value


/*
 * recvmsg()/sendmsg()
 *
 * The same SO_PVD_HANDLE defined above shall be used as the cmsg_type in
 * conjunction with the SOL_SOCKET cmsg_level to specify struct cmsghdr
 * entries for use with recvmsg() and sendmsg().  These have the same



Kline                     Expires April 7, 2016                 [Page 8]

Internet-Draft                  MPvD API                    October 2015


 * effect described above though applicability is limited to the immediate
 * sendmsg()/recvmsg() invocaton and not for the lifetime the socket file
 * descriptor.
 *
 * In certain situations it may be difficult or impossible for an operating
 * system to determing the correct pvd_handle_t for incoming messages (e.g.
 * when there are multiple provisioning domains in a single interface and
 * the system is unable to determine which PVD should be associated with
 * the source of the message.  In such cases, the value returned in the
 * cmsg_data field MAY be PVD_HANDLE. This is not an error, but
 * rather an underspecified situation.
 */


/*
 * accept()
 *
 * If a listening socket is associated with a single PVD, e.g. via a prior
 * call to pvd_set_*_default(...) or setsockopt(SOL_SOCKET, SO_PVD_HANDLE, ...)
 * then traffic arriving from other provisioning domains MUST NOT cause a new
 * connection.
 *
 * Furthermore, whether or not a listening socket has a specified PVD, the
 * specified PVD MUST be set for the accept()ed file descriptor.  Note that
 * in certain situations (e.g. listening socket using PVD_HANDLE_UNSPEC and
 * multiple PVDs on a single interface with insufficient data to map
 * incoming traffic to specific PVDs), the specified PVD MAY be
 * PVD_HANDLE_UNSPEC.  This is not an error, but rather an underspecified
 * situation.
 *
 * More broadly, operating systems SHOULD, wherever possible, implement
 * this style of incoming specified pvd_handle_t reflection for other protocols
 * with similar accept()-style semantics.
 */

/*
 * getaddrinfo w/ pvd_handle_t argument
 */

/*
 * getnameinfo w/ pvd_handle_t argument
 */









Kline                     Expires April 7, 2016                 [Page 9]

Internet-Draft                  MPvD API                    October 2015


8.  TL;DR

   R1  An API call MUST exist whereby an application can learn the
       identifiers, or short handles, of all PvDs active on the system
       at the time.

   R2  An MPvD API implementation MUST include a mechanism whereby an
       application can learn of/be notified of: the arrival of new PvDs
       or the anticipated removal of a PvD.  Actual removal of a PvD can
       be learned by observing any blocking PvD API operation for errors
       indicating the loss of the PvD (e.g. a socket read() returning
       ENONET).

   R3  API implementations that use short handles to reference PvD
       information (identifiers, configuration information) SHOULD
       consider varying the handle used for a specific PvD with each
       separate attach, e.g. a 3GPP connection to "apn.carrier.example"
       might have handle 100 for the first attach after boot, and 101
       for the next attach after going into and coming out of "airplane
       mode".  Because there is no guarantee that the configuration
       information, like delegated prefixes and configured IP addresses,
       will be the same with every successful attachment to the same
       PvD, changing the handle accordingly can help to disabuse
       application writers of erroneous notions of caching PvD
       configuration information from one attachment instance to
       another.

   R4  There MUST be an API call which, when passed a PvD identifier or
       short handle, returns elements of configuration information
       specific to that PvD.

   R5  An MPvD API implementation MUST include a mechanism whereby an
       application can learn of changes to the configuration information
       of a given PvD, e.g. a new temporary address has been formed, a
       new secondary DNS server has replaced the previous secondary, et
       cetera.

   R6  For every element of system functionality that has historically
       been performed in the context of a single, implicit PvD an API
       extension MUST exist allowing the application to specificy that
       the same functionality be performed within the scope of an
       explicitly requested PvD (via identifier or handle).

   R7







Kline                     Expires April 7, 2016                [Page 10]

Internet-Draft                  MPvD API                    October 2015


9.  Requirements for new API functionality

   API implementors SHOULD provide a mechanism for an application to set
   its default PvD, i.e. the PvD to be used by API calls made without
   reference to an explicit PvD.

   API implementors SHOULD provide a mechanism for an application to set
   its default PvD at the granularity of "programming parallelization":
   per-process, per-thread, per-fiber, et cetera.

   Given that PvD identifiers may be of a length or form not easily
   passed around programmatically, API implementions SHOULD consider a
   programmatically simple handle for use with the variety of API calls.
   https://tools.ietf.org/html/rfc7556#section-2.4

   An MPvD API implementation SHOULD consider implementing policy
   controls

10.  Acknowledgements

   The core concepts presented in this document were developed during
   the Android multinetworking effort by Lorenzo Colitti, Robert
   Greenwalt, Paul Jensen, and Sreeram Ramachandran.

   Additional thanks to the coffee shops of Tokyo.

11.  IANA Considerations

   This memo includes no request to IANA.

12.  Security Considerations

   The major new security impact of an MPvD API is that it becomes much
   simpler (by design) to write a functional application to create a
   bridging data path between two PvDs that would not have otherwise
   been directly connected.

   For some operating systems, existing APIs already make this bridging
   possible, though some functionality like DNS resolution may have been
   difficult to implement.  Indeed, the very aim of an MPvD API is to
   make implementing a PvD-aware application simple and to make its
   functioning more "correct" ("first class" support for such
   functionality).

   Operating system implementations have several points of potential
   policy control including:





Kline                     Expires April 7, 2016                [Page 11]

Internet-Draft                  MPvD API                    October 2015


   o  use of certain PvDs MAY be restricted by policy (e.g. only
      approved users, groups, or applications might be permitted
      access), and/or

   o  use of more than one PvD (or the MPvD API itself) MAY be similarly
      restricted.

13.  References

13.1.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.

   [RFC6724]  Thaler, D., Ed., Draves, R., Matsumoto, A., and T. Chown,
              "Default Address Selection for Internet Protocol Version 6
              (IPv6)", RFC 6724, DOI 10.17487/RFC6724, September 2012,
              <http://www.rfc-editor.org/info/rfc6724>.

   [RFC7556]  Anipko, D., Ed., "Multiple Provisioning Domain
              Architecture", RFC 7556, DOI 10.17487/RFC7556, June 2015,
              <http://www.rfc-editor.org/info/rfc7556>.

13.2.  Informative References

   [RFC6418]  Blanchet, M. and P. Seite, "Multiple Interfaces and
              Provisioning Domains Problem Statement", RFC 6418, DOI 10
              .17487/RFC6418, November 2011,
              <http://www.rfc-editor.org/info/rfc6418>.

   [RFC6419]  Wasserman, M. and P. Seite, "Current Practices for
              Multiple-Interface Hosts", RFC 6419, DOI 10.17487/RFC6419,
              November 2011, <http://www.rfc-editor.org/info/rfc6419>.

Author's Address

   Erik Kline
   Google Japan KK
   Roppongi 6-10-1
   Mori Tower, 26th floor
   Minato, Tokyo  106-6128
   JP

   Email: ek@google.com







Kline                     Expires April 7, 2016                [Page 12]
