



Internet Engineering Task Force                                 E. Kline
Internet-Draft                                           Google Japan KK
Intended status: Informational                          October 30, 2015
Expires: May 02, 2016


             Multiple Provisioning Domains API Requirements
                     draft-kline-mif-pvdapireqs-00

Abstract

   RFC 7556 [RFC7556] provides the essential conceptual guidance an API
   designer would need to support use of PvDs.  This document aims to
   capture the requirements for an API that can be used by applications
   that would be considered "advanced", according to section 6.3 [1] of
   RFC 7556 [RFC7556].  The "basic" [2] and "intermediate" [3] API
   support levels can in principle be implemented by means of layers
   wrapping the advanced API.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on May 02, 2016.

Copyright Notice

   Copyright (c) 2015 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of



Kline                     Expires May 02, 2016                  [Page 1]

Internet-Draft            MPvD API Requirements             October 2015


   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   2
     1.1.  Requirements Language . . . . . . . . . . . . . . . . . .   3
   2.  High level requirements . . . . . . . . . . . . . . . . . . .   3
     2.1.  Requirements for an API . . . . . . . . . . . . . . . . .   3
     2.2.  Requirements for supporting operating systems . . . . . .   4
       2.2.1.  Source address selection  . . . . . . . . . . . . . .   5
       2.2.2.  Route isolation . . . . . . . . . . . . . . . . . . .   5
       2.2.3.  Automatic PvD metadata marking  . . . . . . . . . . .   6
       2.2.4.  Additional system and library support . . . . . . . .   6
   3.  Conceptual PvDs . . . . . . . . . . . . . . . . . . . . . . .   6
     3.1.  The 'null' PvD  . . . . . . . . . . . . . . . . . . . . .   6
     3.2.  The 'loopback' PvD  . . . . . . . . . . . . . . . . . . .   7
     3.3.  The 'default' PvD . . . . . . . . . . . . . . . . . . . .   7
   4.  Requirements for new API functionality  . . . . . . . . . . .   7
     4.1.  learning about PvDs . . . . . . . . . . . . . . . . . . .   7
     4.2.  learning information within a PvD . . . . . . . . . . . .   8
     4.3.  scoping functionality to a specific PvD . . . . . . . . .   8
     4.4.  Policy restrictions . . . . . . . . . . . . . . . . . . .   9
     4.5.  Explicit versus Implicit PvDs . . . . . . . . . . . . . .   9
     4.6.  Use of PvD identifiers versus shorthand references  . . .   9
   5.  Updated API functions for scoping functionality to a specific
       PvD . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  10
     5.1.  DNS resolution  . . . . . . . . . . . . . . . . . . . . .  12
   6.  TL;DR . . . . . . . . . . . . . . . . . . . . . . . . . . . .  13
   7.  Acknowledgements  . . . . . . . . . . . . . . . . . . . . . .  13
   8.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  13
   9.  Security Considerations . . . . . . . . . . . . . . . . . . .  13
   10. References  . . . . . . . . . . . . . . . . . . . . . . . . .  14
     10.1.  Normative References . . . . . . . . . . . . . . . . . .  14
     10.2.  Informative References . . . . . . . . . . . . . . . . .  15
   Author's Address  . . . . . . . . . . . . . . . . . . . . . . . .  15

1.  Introduction

   RFC 7556 [RFC7556] provides the essential conceptual guidance an API
   designer would need to support use of PvDs.  This document aims to
   capture the requirements for an API that can be used by applications
   that would be considered "advanced", according to section 6.3 [4] of
   RFC 7556 [RFC7556].  The "basic" [5] and "intermediate" [6] API
   support levels can in principle be implemented by means of layers
   wrapping the advanced API.





Kline                     Expires May 02, 2016                  [Page 2]

Internet-Draft            MPvD API Requirements             October 2015


   This document also attempts to make some of the API implementation
   requirements more concrete by discussion and example.

1.1.  Requirements Language

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119 [RFC2119].

2.  High level requirements

   As described in section 2 [7] of RFC 7556 [RFC7556], a Provisioning
   Domain ("PvD") is fundamentally a "consistent set of network
   configuration information."  This includes information like:

   o  the list of participating interfaces

   o  IPv4 and IPv6 addresses

   o  IPv4 and IPv6 routes: both default routes and more specifics (such
      as may be learned via RFC 4191 [RFC4191] Route Information Options
      ("RIOs"))

   o  DNS nameservers, search path, et cetera

   o  HTTP proxy configuration

   and undoubtedly many more configuration elements yet to be specified
   (like metering hints, transmission medium and speed, captive portal
   URL, et cetera).

   This configuration information as whole may not be able to be learned
   atomically, may need to be synthesized from multiple sources
   including administrative provisioning, and cannot be presumed to be
   unchanging over the lifetime of a node's association with a given
   PvD.

   In order for an application to make consistent use [8] of a given
   PvD's network configuration several requirements are placed upon the
   API itself and the host operating system providing the API.

2.1.  Requirements for an API

   At the highest level, the requirements for an API that enables
   applications to make sophisticated use of multiple PvDs amount to
   providing mechanisms by which they can:

   R1  observe accessible PvDs



Kline                     Expires May 02, 2016                  [Page 3]

Internet-Draft            MPvD API Requirements             October 2015


       It MUST be possible for an application to be informed of the set
       of all PvDs it can currently access, and to be informed of
       changes to this set.

   R2  observe configuration elements of an accessible PvD

       It MUST be possible to learn requested configuration information
       of any accessible PvD, and to be informed of any changes to the
       configuration information comprising an accessible PvD.

   R3  scope networking functionality to a specified PvD

       For every existing API function that interacts with the node's
       networking stack, be it at a relatively high level like
       getaddrinfo() [9] or at the level of something like Sockets API's
       sendmsg(), there MUST be a means by which an application can
       specify the PvD within which networking operations are to be
       restricted.

   It is import to note that there is always a provisioning domain
   within which networking functionality is scoped.  For simply-
   connected hosts this may be the implicit PvD [10] created by a single
   networking interface connected to a traditional, shared LAN segment.
   For multihomed hosts the "default provisioning domain" is likely a
   matter of policy, but MAY be a "null" PvD, i.e. one completely devoid
   of networking configuration information (no addresses, no routes, et
   cetera).  See Section 3 for further discussion.

   The utility of such an API (allowing applications to learn of and
   control the scope of networking functionality) suggests that the
   Provisioning Domain is perhaps a more useful operational definition
   for the original IPv6 concept of a "site-local scope" than the ill-
   fated [RFC3879], "ill-defined concept" [11] of a site.  It also
   suggests one possible way by which host operating support for a PvD-
   aware API might be implemented.

2.2.  Requirements for supporting operating systems

   The multiple PvD model of host behaviour is perhaps closer to the
   Strong End System Model than the Weak End System Model characterized
   in RFC 1122 [RFC1122] section 3.3.4.2 [12], but owing to its
   recognition of a many-to-many relationship between interfaces and
   PvDs should be considered a unique model unto itself.

   In the PvD-aware End System Model, the "two key requirement issues
   related to multihoming" are restated as:





Kline                     Expires May 02, 2016                  [Page 4]

Internet-Draft            MPvD API Requirements             October 2015


   a.  A host MAY silently discard an incoming datagram whose
       destination address does not correspond to any PvD associated
       with the physical (or virtual) interface through which it is
       received.

   b.  A host MUST restrict itself to sending (non-source-routed) IP
       datagrams only through the physical (or virtual) interfaces that
       correspond to the PvD associated with the IP source address of
       the datagrams.

   In order to support a PvD-aware application's use of multiple PVDs,
   several additional requirements must be met by the host operating
   system, especially when performing functions on behalf of
   applications or when no direct application intervention is possible,
   as discussed in the following sections.

2.2.1.  Source address selection

   Whenever a source address is to be selected on behalf of an
   application it is essential for consistent use that only source
   addresses belonging to the currently scoped PvD be used a candidate
   set.  (See RFC 6418 [RFC6418] section 3.5 [13] for references to
   issues arising from poor source address selection.)

   For nodes following the PvD-aware End System Model, RFC 6724
   [RFC6724] section 4 [14] is amended as follows:

   R4  The candidate source addresses MUST be restricted to the set of
       unicast addresses associated with the (explicitly or implicitly)
       specified PvD.

       Additionally, source address selection policies from PvDs other
       than the (explicitly or implicitly) specified PvD MUST NOT be
       applied.

2.2.2.  Route isolation

   Whenever a routing lookup for destination is to be performed, it is
   essential that only routes belonging to the currently scoped PvD be
   consulted.  Applications and libraries that use the inherent routing
   reachability check (and subsequent source address selection)
   performed during something like the Sockets API connect() call on a
   UDP socket to learn reachability information cheaply cannot function
   correctly otherwise.  RFC 6418 [RFC6418] section 4.2 [15] contains
   more discussion and references to issues arising from insufficiently
   isolated routing information.

   For nodes following the PvD-aware End System Model:



Kline                     Expires May 02, 2016                  [Page 5]

Internet-Draft            MPvD API Requirements             October 2015


   R5  The set of routes consulted for any routing decision MUST be
       restricted to the routes associated with the (explicitly or
       implicitly) specified PvD.

2.2.3.  Automatic PvD metadata marking

   In many cases, an application can examine a source address or the
   destination address of a received datagram and use that address's
   association with a given PvD to learn, for example, the PvD with
   which an incoming connection may be associated.  It may, however, be
   impossible for an application to make this determination on its own
   if, for example, an incoming TCP connection is destined to a RFC 1918
   [RFC1918] address that happens to be configured in multiple PvDs at
   the same time.  In such circumstances, the supporting operating
   system will need to provide additional assistance.

   For nodes following the PvD-aware End System Model:

   R6  For networking functionality performed on behalf of an
       application, the supporting operating system MUST record and make
       available to the application either (1) all the information the
       application might need to make a PvD evaluation on its own or (2)
       the PvD identifier (or an equivalent shorthand reference thereto,
       whichever is most useful within the context of the API) directly.

       A supporting operating system SHOULD record and make available
       the PvD identifier (or an equivalent reference); other approaches
       invite ambiguity among applications' interpretation of available
       information.

2.2.4.  Additional system and library support

   Frequently, operating systems have several additional supporting
   libraries and services for more advance networking functionality.
   Using the system's own PvD API, meeting the above requirements, it
   should be possible to extend them to provide correct per-PvD
   isolation of information and application support.

3.  Conceptual PvDs

3.1.  The 'null' PvD










Kline                     Expires May 02, 2016                  [Page 6]

Internet-Draft            MPvD API Requirements             October 2015


   Useful to ensure networking functions fail (and fail quickly) If
   there are no PvDs accessible to a user/group/application, either as a
   matter of policy (insufficient privileges) or as a matter of natural
   circumstance (the node is not connected to any network), the 'null'
   PvD may be a suitable PvD for the API to return to application
   queries or to apply as the PvD of use in the absence of other
   explicitly reference PvDs.

3.2.  The 'loopback' PvD

   - useful to scope networking functions to the node only - has only
   locally assigned addresses and routes specifying local delivery and
   no default routes - MAY have other configuration elements consisting
   of locally accessible services - TODO: ask for help/clarification
   here

3.3.  The 'default' PvD

   PvD-aware system as a whole SHOULD have a notion of currently active
   default PvD

   - makes "basic 6.1" trivial - without this application behaviour will
   be highly system dependent (does the system iterate through PvDs, in
   some order, trying to find a PvD in which a certain op succeeds?) -
   this is the PvD to use for operations for which a PvD must be
   selected and no explicity PvD API has been used - as a matter of
   policy, this MAY be a "null" PvD, effectively requiring all apps to
   be PvD-aware, or "loopback" to permit locally communications only for
   non-PvD-aware apps - SHOULD be a way to communicate changes in the
   default PvD - MUST be able to specify that the default PvD is to be
   used

   For backward compatibility for non-PvD-aware applications, there MUST
   exist a "default PvD", i.e. a PvD within which system functions
   requiring a PvD are to be performed.

   It is expected that most nodes will use a variety of information
   coupled with administrative policy to promote one of a number of
   currently active PvDs to be the default for ease of backward
   compatibility, and to promote another active PvD in its place as
   circumstances change.

   TBD: 'PVD_UNSPEC'

4.  Requirements for new API functionality

4.1.  learning about PvDs




Kline                     Expires May 02, 2016                  [Page 7]

Internet-Draft            MPvD API Requirements             October 2015


   This data generally does not become available to a node in an atomic
   fashion, and can change over time (RAs with 6106 that add or replace
   DNS servers in previous RAs, ...).  Routes and prefixes can come and
   go and yet all be part of the same provisioning domain.  An API call
   MUST exist whereby an application can learn the identifiers, or short
   handles, of all PvDs active on the system at the time.  - MUST
   existence (subject to policy) - both implicit and explicit PvDs must
   also be included in the API response - updates to availability -
   SHOULD new - MAY going away (useful) - MAY gone (app may also learn
   via errors) The same PvD may arrive on another interface (3GPP
   interface and WLAN -- find 3gpp spec reference).  An MPvD API
   implementation MUST include a mechanism whereby an application can
   learn of/be notified of: the arrival of new PvDs or the anticipated
   removal of a PvD.  Actual removal of a PvD can be learned by
   observing any blocking PvD API operation for errors indicating the
   loss of the PvD (e.g. a socket read() returning ENONET).

4.2.  learning information within a PvD

   - configuration - SHOULD be an API to get configuration information
   for a specific PvD - SHOULD configuration changes (app may also learn
   via errors) - such an API MUST be easily extensible to support
   configuration information not yet considered Reason to be extensible:
   - methods to get attributes of a PVD, like whether it is comprised of
   a mobile link versus wifi/ethernet, whether there is some metering/
   charging associated with traffic sent/received via this PVD or not,
   etc.  This API MUST be extensible, as PvD information is not
   guaranteed to be learned atomically nor is it guaranteed to be
   static.  Furthermore, this API needs to be extensible in order to
   accommodate requesting new configuration information not yet
   conceived of at this time, e.g. a new FOO protocol is used within a
   given PvD and it's important for applications to learn that they need
   to use the proxy BAR for best performance.  - get PvD configuration
   data - notification of configuration changes - figure out how to
   express PvD : interface/scope_id relationship

4.3.  scoping functionality to a specific PvD

   API implementors SHOULD provide a mechanism for an application to set
   its default PvD, i.e. the PvD to be used by API calls made without
   reference to an explicit PvD.  API implementors SHOULD provide a
   mechanism for an application to set its default PvD at the
   granularity of "programming parallelization": per-process, per-
   thread, per-fiber, et cetera.  - PvD-aware applications need to be
   able to specify that some functionality should be scoped to an
   implicit PvD - apps SHOULD be able to specify which PvD is to be used
   for network-related functionality at the granularity of programming
   parallelism: - per-process (and child processes) - per-thread - per-



Kline                     Expires May 02, 2016                  [Page 8]

Internet-Draft            MPvD API Requirements             October 2015


   fiber - useful for being able to start non-PvD-aware apps within a
   single PvD context unbeknownst to them and operate correctly -
   indeed, this could be used as a definition / validation that a PvD
   implemention is correct: non-PvD-aware apps function correctly, with
   no negative impact, in a single PvD without being PvD-aware - also
   per application control (e.g. process groups) // Retrieve the current
   "default" PVD.  If the return type is // PVD_HANDLE_INVALID there may
   be no PVD accessible to this process // at this time or no system
   support for this API.  // // These values are used by PVD-aware
   function calls when a PVD index // is not explicitly specified.
   pvd_handle_t pvd_system_default(); // Same as above, but operates at
   a per-process level.  If no // process-specific default has been set
   this MUST return the value // of a call to
   pvd_current_system_default().  pvd_handle_t pvd_process_default(); //
   Same as above, but operates at a per-thread level.  If no // thread-
   specific default has been set this MUST return the value // of a call
   to pvd_current_process_default().  pvd_handle_t pvd_thread_default();
   int pvd_set_process_default(pvd_handle_t); int
   pvd_set_thread_default(pvd_handle_t); // Any function that is not
   easily extended to support a pvd_handle_t // argument, but for which
   the underlying operating system understands // the process-global or
   per-thread pvd_index can be wrapped to create // a PVD-aware variant
   like so: // // return_type pvd_functioname(pvd_handle_t pvdix,
   regular arguments...) { // pvd_handle_t saved = pvd_thread_default();
   // if (pvd_set_thread_default(pvdix) != 0) { // // handle error //
   return error_indicator_value; // } // return_type result =
   functionname(regular arguments...); // pvd_set_thread_default(saved);
   // Should error-check // return result; // }

4.4.  Policy restrictions

   An MPvD API implementation MAY implement policy controls whereby
   access to PvD availability, configuration information, and explicit
   scoping requests are variously permitted or denied to certain
   applications.

4.5.  Explicit versus Implicit PvDs

   - the API used by PvD-aware applications MUST support both implicit
   and explicit PvDs - It SHOULD NOT be necessary for a PvD-aware
   application to distinguish between explicit and implicit PvDs.  Both
   SHOULD be equally accessible and useful via the same API calls.  -
   PvD-aware nodes should provide PvD identifiers for implicit PvDs that
   can be used without application change in the same ways as explicit
   PvDs

4.6.  Use of PvD identifiers versus shorthand references




Kline                     Expires May 02, 2016                  [Page 9]

Internet-Draft            MPvD API Requirements             October 2015


   shorthand reference, "handle", "token" - node-specific token used to
   identify an instance of a single provisioning domain's configuration
   data // Not guaranteed to be stable across across associations to a
   PVD.  // // The same PVD may have different pvd_handle_t's if, for
   example, // when reattaching later to the same PVD (returning home in
   the // evening), the same PVD may be assigned a different
   pvd_handle_t.  // // The pvd_handle_t must remain valid until a
   disconnection or // disassociation event occurs, after which the
   pvd_handle_t MUST NOT // be recycled to refer to a different PVD so
   long as there remain // any identifiable references to it (e.g. a
   process or thread still // has this PVD index set as its default).  /
   / // Applications explicitly specifying PVD indices to PVD-aware //
   functions are not readily identifiable (indeed an application //
   could progressively walk the PVD index space attempting various //
   function calls without ever having received any indication from //
   the system that a given index was valid).  In order to account for //
   this, PVD indices SHOULD NOT be recycled, to the extent possible.  //
   One acceptable implementation approach is to assign every new PVD //
   context a strictly monotonically increasing index, such that any //
   specific index is not reused until the unsigned integer space has //
   been completely exhausted, before restarting again from 1.  // The
   value PVD_HANDLE_UNSPEC is used to indicate no specific PVD.  // //
   Depending on the context it may indicate that the system does not //
   implement support for the Provisioning Domain API, an error, or // a
   signal to "clear" previous PVD index state.

   Given that PvD identifiers may be of a length or form not easily
   passed around programmatically, API implementions SHOULD consider a
   programmatically simple handle for use with the variety of API calls.
   https://tools.ietf.org/html/rfc7556#section-2.4

5.  Updated API functions for scoping functionality to a specific PvD

   - everything that implicitly used a single PvD, e.g. when a single
   interface was connected to a single PvD network, SHOULD be extended
   to be invoked with a PvD argument

   In order to ease porting of non-PVD-aware applications as well as
   support non-PVD-aware applications in accordance with the principle
   of least surprise it is recommended that the following functionality
   be added to existing system networking APIs.

   sockets API - setsockopt() / getsockopt() - IP_RECVPVD / IPV6_RECVPVD
   - recvmsg() should include indication of PVD to which the packet
   arrived - IP_PVD / IPV6_PVD - source address selection and applicable
   routing table is restricted to the specified PvD - if a source
   address has already been selected from one PvD, transmitting via
   another PvD is NOT RECOMMENDED (but of course possible) -



Kline                     Expires May 02, 2016                 [Page 10]

Internet-Draft            MPvD API Requirements             October 2015


   PVD_UNSPECIFIED - no PvD explicitly requested - also used to clear a
   process or thread default and revert to system default - for PF_INET
   / PF_INET6 sockets - socket() - if a process-default or thread-
   default PvD has been set, the returned file descriptor must be
   "bound" to the PvD - i.e. as if setsockopt(SOL_IPV6, IPV6_PVD, ...)
   had been called - otherwise, the file descriptor defaults to
   PVD_UNSPECIFIED - bind() - if a PvD is specified and address is
   unspecified, it is RECOMMENDED source address selection be restricted
   to this PVD - else if a PvD is specified and address is not
   unspecified, EADDRNOTAVAIL might be returned - else best effort /
   system-specific policies apply - listen() - if the file descriptor is
   already bound to a PvD, only traffic to one of the PvD's addresses
   should cause the file descriptor to become readable - other traffic
   should receive an ICMP error - accept() - returned file descriptors
   should be bound to the PvD of: - the listening socket, if it was not
   bound to PVD_UNSPECIFIED - the PvD of the destination address on the
   system - connect() - bind() discussion applies for source address
   selection - EHOSTUNREACH / ENETUNREACH might be returned sendmsg() /
   recvmsg() cmsg semantics - setsockopt() / getsockopt() options apply
   - IP_RECVPVD / IPV6_RECVPV6 - IP_PVD / IPV6_PVD

   - sockets examples:



   /*
    * getsockopt()/setsockopt()
    *
    * The header file <sys/socket.h> SHALL define SO_PVD_HANDLE in supporting
    * implementations, for use with getsockopt/setsockopt and the SOL_SOCKET
    * level.  The option_value shall be understood to be a pointer to a
    * pvd_handle_t and the option_len is required to be sizeof(pvd_handle_t).
    *
    * Setting the SO_PVD_HANDLE option constrains all operations on the
    * specified socket to function only within the specified PVD currently
    * described by pvd_handle_t.  If the pvd_handle_t argument has the value
    * PVD_HANDLE then the operating-system policy-defined default is
    * to be used (see <net/pvd.h>).
    */

   /*
    * recvmsg()/sendmsg()
    *
    * The same SO_PVD_HANDLE defined above shall be used as the cmsg_type in
    * conjunction with the SOL_SOCKET cmsg_level to specify struct cmsghdr
    * entries for use with recvmsg() and sendmsg().  These have the same
    * effect described above though applicability is limited to the immediate
    * sendmsg()/recvmsg() invocaton and not for the lifetime the socket file



Kline                     Expires May 02, 2016                 [Page 11]

Internet-Draft            MPvD API Requirements             October 2015


    * descriptor.
    *
    * In certain situations it may be difficult or impossible for an operating
    * system to determing the correct pvd_handle_t for incoming messages (e.g.
    * when there are multiple provisioning domains in a single interface and
    * the system is unable to determine which PVD should be associated with
    * the source of the message.  In such cases, the value returned in the
    * cmsg_data field MAY be PVD_HANDLE. This is not an error, but
    * rather an underspecified situation.
    */

   /*
    * accept()
    *
    * If a listening socket is associated with a single PVD, e.g. via a prior
    * call to pvd_set_*_default(...) or setsockopt(SOL_SOCKET, SO_PVD_HANDLE, ...)
    * then traffic arriving from other provisioning domains MUST NOT cause a new
    * connection.
    *
    * Furthermore, whether or not a listening socket has a specified PVD, the
    * specified PVD MUST be set for the accept()ed file descriptor.  Note that
    * in certain situations (e.g. listening socket using PVD_HANDLE_UNSPEC and
    * multiple PVDs on a single interface with insufficient data to map
    * incoming traffic to specific PVDs), the specified PVD MAY be
    * PVD_HANDLE_UNSPEC.  This is not an error, but rather an underspecified
    * situation.
    *
    * More broadly, operating systems SHOULD, wherever possible, implement
    * this style of incoming specified pvd_handle_t reflection for other protocols
    * with similar accept()-style semantics.
    */



5.1.  DNS resolution

   For nodes following the PvD-aware End System Model:

   R7  A PVD-aware API MUST make it possible for an application to
       perform normal name resolution constrained to the name resolution
       configuration within a specified PVD.  /* * getaddrinfo w/
       pvd_handle_t argument */ /* * getnameinfo w/ pvd_handle_t
       argument */ Implementations of RFC 3493 [RFC3493] section 6.1
       [16] getaddrinfo() - getaddrinfo() and AI_ADDRCONFIG -
       RFC3493#section-6.1 "...shall be returned only if an IPv4/v6
       address is configured on the local system..." -> "... within the
       requested PvD"




Kline                     Expires May 02, 2016                 [Page 12]

Internet-Draft            MPvD API Requirements             October 2015


6.  TL;DR

   R8  API implementations that use short handles to reference PvD
       information (identifiers, configuration information) SHOULD
       consider varying the handle used for a specific PvD with each
       separate attach, e.g. a 3GPP connection to "apn.carrier.example"
       might have handle 100 for the first attach after boot, and 101
       for the next attach after going into and coming out of "airplane
       mode".  Because there is no guarantee that the configuration
       information, like delegated prefixes and configured IP addresses,
       will be the same with every successful attachment to the same
       PvD, changing the handle accordingly can help to disabuse
       application writers of erroneous notions of caching PvD
       configuration information from one attachment instance to
       another.

   R9  There MUST be an API call which, when passed a PvD identifier or
       short handle, returns elements of configuration information
       specific to that PvD.

   R10 An MPvD API implementation MUST include a mechanism whereby an
       application can learn of changes to the configuration information
       of a given PvD, e.g. a new temporary address has been formed, a
       new secondary DNS server has replaced the previous secondary, et
       cetera.

   R11 For every element of system functionality that has historically
       been performed in the context of a single, implicit PvD an API
       extension MUST exist allowing the application to specificy that
       the same functionality be performed within the scope of an
       explicitly requested PvD (via identifier or handle).

7.  Acknowledgements

   The core concepts presented in this document were developed during
   the Android multinetworking effort by Lorenzo Colitti, Robert
   Greenwalt, Paul Jensen, and Sreeram Ramachandran.

   Additional thanks to the coffee shops of Tokyo.

8.  IANA Considerations

   This memo includes no request to IANA.

9.  Security Considerations

   Consider whether 7556 section 8 should be referenced.  Possibly not,
   since those seem to be focused on external PvD-altering threats.



Kline                     Expires May 02, 2016                 [Page 13]

Internet-Draft            MPvD API Requirements             October 2015


   The major new security impact of an MPvD API is that it becomes much
   simpler (by design) to write a functional application to create a
   bridging data path between two PvDs that would not have otherwise
   been directly connected.

   For some operating systems, existing APIs already make this bridging
   possible, though some functionality like DNS resolution may have been
   difficult to implement.  Indeed, the very aim of an MPvD API is to
   make implementing a PvD-aware application simple and to make its
   functioning more "correct" ("first class" support for such
   functionality).

   Operating system implementations have several points of potential
   policy control including:

   o  use of certain PvDs MAY be restricted by policy (e.g. only
      approved users, groups, or applications might be permitted
      access), and/or

   o  use of more than one PvD (or the MPvD API itself) MAY be similarly
      restricted.

10.  References

10.1.  Normative References

   [RFC1122]  Braden, R., Ed., "Requirements for Internet Hosts -
              Communication Layers", STD 3, RFC 1122, DOI 10.17487/
              RFC1122, October 1989,
              <http://www.rfc-editor.org/info/rfc1122>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.

   [RFC3493]  Gilligan, R., Thomson, S., Bound, J., McCann, J., and W.
              Stevens, "Basic Socket Interface Extensions for IPv6", RFC
              3493, DOI 10.17487/RFC3493, February 2003,
              <http://www.rfc-editor.org/info/rfc3493>.

   [RFC6724]  Thaler, D., Ed., Draves, R., Matsumoto, A., and T. Chown,
              "Default Address Selection for Internet Protocol Version 6
              (IPv6)", RFC 6724, DOI 10.17487/RFC6724, September 2012,
              <http://www.rfc-editor.org/info/rfc6724>.

   [RFC7556]  Anipko, D., Ed., "Multiple Provisioning Domain
              Architecture", RFC 7556, DOI 10.17487/RFC7556, June 2015,
              <http://www.rfc-editor.org/info/rfc7556>.




Kline                     Expires May 02, 2016                 [Page 14]

Internet-Draft            MPvD API Requirements             October 2015


10.2.  Informative References

   [RFC1918]  Rekhter, Y., Moskowitz, R., Karrenberg, D., Groot, G., and
              E. Lear, "Address Allocation for Private Internets", BCP
              5, RFC 1918, February 1996.

   [RFC3879]  Huitema, C. and B. Carpenter, "Deprecating Site Local
              Addresses", RFC 3879, DOI 10.17487/RFC3879, September
              2004, <http://www.rfc-editor.org/info/rfc3879>.

   [RFC4191]  Draves, R. and D. Thaler, "Default Router Preferences and
              More-Specific Routes", RFC 4191, DOI 10.17487/RFC4191,
              November 2005, <http://www.rfc-editor.org/info/rfc4191>.

   [RFC6418]  Blanchet, M. and P. Seite, "Multiple Interfaces and
              Provisioning Domains Problem Statement", RFC 6418, DOI
              10.17487/RFC6418, November 2011,
              <http://www.rfc-editor.org/info/rfc6418>.

   [RFC6419]  Wasserman, M. and P. Seite, "Current Practices for
              Multiple-Interface Hosts", RFC 6419, DOI 10.17487/RFC6419,
              November 2011, <http://www.rfc-editor.org/info/rfc6419>.

Author's Address

   Erik Kline
   Google Japan KK
   6-10-1 Roppongi
   Mori Tower, 44th floor
   Minato, Tokyo  106-6126
   JP

   Email: ek@google.com


















Kline                     Expires May 02, 2016                 [Page 15]
