



Internet Engineering Task Force                            E. Kline, Ed.
Internet-Draft                                           Google Japan KK
Intended status: Informational                          October 04, 2015
Expires: April 06, 2016


       Multiple Provisioning Domains Application API Requirements
                 draft-kline-mif-pvd-application-api-00

Abstract

   Insert an abstract: MANDATORY.  This template is for creating an
   Internet Draft.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on April 06, 2016.

Copyright Notice

   Copyright (c) 2015 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.






Kline                    Expires April 06, 2016                 [Page 1]

Internet-Draft            MPVD Application API              October 2015


Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   2
     1.1.  Requirements Language . . . . . . . . . . . . . . . . . .   3
   2.  High level requirements . . . . . . . . . . . . . . . . . . .   3
     2.1.  API functional requirements . . . . . . . . . . . . . . .   3
     2.2.  Operating system requirements . . . . . . . . . . . . . .   3
   3.  New API functions for learning about PvDs . . . . . . . . . .   4
   4.  New API functions for scoping functionality to a specific PvD   4
   5.  Updated API functions for scoping functionality to a specific
       PvD . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   4
   6.  Special use PvDs  . . . . . . . . . . . . . . . . . . . . . .   4
   7.  TL;DR . . . . . . . . . . . . . . . . . . . . . . . . . . . .   5
     7.1.  Requirements for a mPvD API implementation  . . . . . . .   6
     7.2.  Recommendations for a mPvD API implementation . . . . . .   6
   8.  Discussion  . . . . . . . . . . . . . . . . . . . . . . . . .   6
   9.  Requirements for new API functionality  . . . . . . . . . . .   6
   10. Requirements for updates to existing API functionality  . . .   7
   11. a . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   7
   12. b . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   7
   13. Host Operating System Requirements  . . . . . . . . . . . . .   7
   14. c . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   7
   15. New API Definitions . . . . . . . . . . . . . . . . . . . . .   7
   16. Extensions for Existing Sockets API Functions . . . . . . . .   7
   17. Acknowledgements  . . . . . . . . . . . . . . . . . . . . . .   7
   18. IANA Considerations . . . . . . . . . . . . . . . . . . . . .   8
   19. Security Considerations . . . . . . . . . . . . . . . . . . .   8
   20. References  . . . . . . . . . . . . . . . . . . . . . . . . .   8
     20.1.  Normative References . . . . . . . . . . . . . . . . . .   8
     20.2.  Informative References . . . . . . . . . . . . . . . . .   8
   Appendix A.  Comparison with Android implementation . . . . . . .   9
   Author's Address  . . . . . . . . . . . . . . . . . . . . . . . .   9

1.  Introduction

   RFC 7556 provides all the essential guidance an API designer would
   need to support use of PvDs.  This document aims to make some of the
   implications more concrete by discussion and example.

   All system functionality that has historically been performed in the
   context of a single, implicit PvD must be updated to support the same
   operations on an explicitly requested PvD.

   For backward compatibility for non-PvD-aware applications, there MUST
   exist a "default PvD", i.e. a PvD within which system functions
   requiring a PvD are to be performed.





Kline                    Expires April 06, 2016                 [Page 2]

Internet-Draft            MPVD Application API              October 2015


   Such a PvD MAY be a "null" or "empty" PvD: one in which no addresses
   or routes of any address family are configured and devoid of
   configuration information of any kind.  A system for which he default
   PvD was such a "null" PvD would effectively require all applications
   to be fully PvD-aware in order to function.

   It is expected that most nodes will use a variety of information and
   administrative policy to promote one of a number of currently active
   PvDs to be the default for ease of backward compatibility, and to
   promote another active PvD in its place as circumstances change.

1.1.  Requirements Language

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119 [RFC2119].

2.  High level requirements

2.1.  API functional requirements

   At a high level, the functional requirements of a multiple
   provisioning domain API ("MPvD API") are:

   1.  learn about the availability of PvDs

   2.  learn about the configuration contents of those PvDs

   3.  allow the application to specify that certain functionality
       should be executed within the scope of a particular PvD

2.2.  Operating system requirements

   - more like a strong host model, but one which scopes operations to
   PvDs not interfaces (include weak/strong and m:n pvd:intf references)
   - http://tools.ietf.org/html/rfc1122 section 3.3.4.2: Strong/Weak ES
   model - PvD IDs could be thought of as site-local scopes - required
   support includes: - route isolation - address isolation, update to
   RFC6724 section 4 - actions peformed by the system must set PvD scope
   automatically, even for non-PvD apps: - TCP accept() - incoming
   datagrams to a UDP server - necessary for any API to provide
   consistent and correct behaviour









Kline                    Expires April 06, 2016                 [Page 3]

Internet-Draft            MPVD Application API              October 2015


3.  New API functions for learning about PvDs

   - MUST existence (subject to policy) - both implicit and explicit
   PvDs must also be included in the API response - PvD-aware
   applications need to be able to specify that some functionality
   should be scoped to an implicit PvD - updates to availability -
   SHOULD new - SHOULD configuration changes (app may also learn via
   errors) - MAY going away (useful) - MAY gone (app may also learn via
   errors) - configuration - SHOULD be an API to get configuration
   information for a specific PvD - such an API MUST be easily
   extensible to support configuration information not yet considered

4.  New API functions for scoping functionality to a specific PvD

   - apps SHOULD be able to specify which PvD is to be used for network-
   related functionality at the granularity of programming parallelism:
   - per-process (and child processes) - per-thread - per-fiber - useful
   for being able to start non-PvD-aware apps within a single PvD
   context unbeknownst to them and operate correctly - indeed, this
   could be used as a definition / validation that a PvD implemention is
   correct: non-PvD-aware apps function correctly, with no negative
   impact, in a single PvD without being PvD-aware

5.  Updated API functions for scoping functionality to a specific PvD

   - everything that implicitly used a single PvD, e.g. when a single
   interface was connected to a single PvD network, SHOULD be extended
   to be invoked with a PvD argument - sockets examples:

6.  Special use PvDs

   - "null" - useful to ensure networking functions fail (and fail
   quickly) - "loopback" - useful to scope networking functions to the
   node only - has only locally assigned addresses and routes specifying
   local delivery and no default routes - MAY have other configuration
   elements consisting of locally accessible services - TODO: ask for
   help/clarification here - "default": PvD-aware system as a whole
   SHOULD have a notion of currently active default PvD - without this
   application behaviour will be highly system dependent (does the
   system iterate through PvDs, in some order, trying to find a PvD in
   which a certain op succeeds?) - this is the PvD to use for operations
   for which a PvD must be selected and no explicity PvD API has been
   used - as a matter of policy, this MAY be a "null" PvD, effectively
   requiring all apps to be PvD-aware, or "loopback" to permit locally
   communications only for non-PvD-aware apps - SHOULD be a way to
   communicate changes in the default PvD - MUST be able to specify that
   the default PvD is to be used




Kline                    Expires April 06, 2016                 [Page 4]

Internet-Draft            MPVD Application API              October 2015


7.  TL;DR

   R1  An API call MUST exist whereby an application can learn the
       identifiers, or short handles, of all PvDs active on the system
       at the time.

   R2  An mPvD API implementation MUST include a mechanism whereby an
       application can learn of/be notified of: the arrival of new PvDs
       or the anticipated removal of a PvD.  Actual removal of a PvD can
       be learned by observing any blocking PvD API operation for errors
       indicating the loss of the PvD (e.g. a socket read() returning
       ENONET).

   R3  API implementations that use short handles to reference PvD
       information (identifiers, configuration information) SHOULD
       consider varying the handle used for a specific PvD with each
       separate attach, e.g. a 3GPP connection to "apn.carrier.example"
       might have handle 100 for the first attach after boot, and 101
       for the next attach after going into and coming out of "airplane
       mode".  Because there is no guarantee that the configuration
       information, like delegated prefixes and configured IP addresses,
       will be the same with every successful attachment to the same
       PvD, changing the handle accordingly can help to disabuse
       application writers of erroneous notions of caching PvD
       configuration information from one attachment instance to
       another.

   R4  There MUST be an API call which, when passed a PvD identifier or
       short handle, returns elements of configuration information
       specific to that PvD.

   R5  This API MUST be extenible, as PvD information is not guaranteed
       to be learned atomically nor is it guaranteed to be static.
       Furthermore, this API needs to be extensible in order to
       accomodate requesting new configuration information not yet
       conceived of at this time, e.g. a new FOO protocol is used within
       a given PvD and it's important for applications to learn that
       they need to use the proxy BAR for best performance.

   R6  An mPvD API implementation MUST include a mechanism whereby an
       application can learn of changes to the configuration information
       of a given PvD, e.g. a new temporary address has been formed, a
       new secondary DNS server has replaced the previous secondary, et
       cetera.

   R7  For every element of system functionality that has historically
       been performed in the context of a single, implicit PvD an API
       extension MUST exist allowing the application to specificy that



Kline                    Expires April 06, 2016                 [Page 5]

Internet-Draft            MPVD Application API              October 2015


       the same functionality be performed within the scope of an
       explicitly requested PvD (via identifier or handle).

7.1.  Requirements for a mPvD API implementation

7.2.  Recommendations for a mPvD API implementation

8.  Discussion

   Two major categories of PvD application API requirements: - learning
   about PvDs - existence and changes in availability - configuration
   data contained within a PvD ID and changes of configuration
   information - selection of a PvD to scope various operations: -
   selection of configuration information - selection of source
   addresses - selection of routing information (consistent use) https:/
   /tools.ietf.org/html/rfc7556#section-5.2

   High-level API requirements are: - it must be possible to learn of
   pvds coming and going - it should be possible to learn pvd
   configuration information and updates - everything done today with an
   implicit pvd assumed must be doable with an explicit pvd

   The rest of this document is concerned with: - identifying new system
   requirements - identifying some existing uses of implicit pvds that
   will need to be updated to support explicit pvds

9.  Requirements for new API functionality

   API implementors SHOULD provide a mechanism for an application to set
   its default PvD, i.e. the PvD to be used by API calls made without
   reference to an explicit PvD.

   API implementors SHOULD provide a mechanism for an application to set
   its default PvD at the granularity of "programming parallelization":
   per-process, per-thread, per-fiber, et cetera.

   Given that PvD identifiers may be of a length or form not easily
   passed around programmatically, API implementions SHOULD consider a
   programmatically simple handle for use with the variety of API calls.
   https://tools.ietf.org/html/rfc7556#section-2.4

   An mPvD API implementation SHOULD consider implementing policy
   controls

   o  get currently available PvDs

   o  get current default PvD, if system supports concept of default




Kline                    Expires April 06, 2016                 [Page 6]

Internet-Draft            MPVD Application API              October 2015


   o  get notified of changes to the set of available PvDs: new, change
      in default

   o  set default PvD per process and per thread

   o  all config info, learn mapping between interfaces and PvD IDs/
      handles, must be extensible

   o  ...

10.  Requirements for updates to existing API functionality

   In order to ease porting of non-PVD-aware applications as well as
   support non-PVD-aware applications in accordance with the principle
   of least surprise it is recommended that the following functionality
   be added to existing system networking APIs.

11.  a

12.  b

   ## 1 PvD . RFC7556 section 2 . "A consistent set of network
   configuration information..." - includes: - participating interfaces
   - addresses - routes (default routes and more specifics) - but also
   RIO -type information - DNS servers and search path - HTTP proxy -
   yet to be specified: metering, medium, captive portal URL, ...  - not
   learned atomically - not static

13.  Host Operating System Requirements

   In order to support the application's use of multiple PVDs, several
   requirements must be fulfilled by the part of the host operating
   system authorized to perform the required functions.

14.  c

15.  New API Definitions

16.  Extensions for Existing Sockets API Functions

17.  Acknowledgements

   The core concepts captured in this document were developed during the
   Android multinetworking effort by Lorenzo Colitti, Robert Greenwalt,
   Paul Jensen, and Sreeram Ramachandran.

   Additional thanks to the coffee shops of Tokyo.




Kline                    Expires April 06, 2016                 [Page 7]

Internet-Draft            MPVD Application API              October 2015


18.  IANA Considerations

   This memo includes no request to IANA.

19.  Security Considerations

   The major new security impact of an mPvD API is that it becomes much
   simpler (by design) to write a functional application to create a
   bridging data path between two PvDs that would not have otherwise
   been directly connected.

   For some operating systems, existing APIs already make this bridging
   possible, though some functionality like DNS resolution may have been
   difficult to implement.  Indeed, the very aim of an mPvD API is to
   make implementing a PvD-aware application simple and to make its
   functioning more "correct" ("first class" support for such
   functionality).

   Operating system implementations have several points of potential
   policy control including:

   o  use of certain PvDs MAY be restricted by policy (e.g. only
      approved users, groups, or individual applications might be
      granted access), and/or

   o  use of more than one PvD (or the mPvD API itself) MAY be
      restricted by policy (e.g. only approved users, groups, or
      individual applications might be granted access).

20.  References

20.1.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.

   [min_ref]  authSurName, authInitials., "Minimal Reference", 2006.

20.2.  Informative References

   [DOMINATION]
              Mad Dominators, Inc., "Ultimate Plan for Taking Over the
              World", 1984, <http://www.example.com/dominator.html>.

   [I-D.narten-iana-considerations-rfc2434bis]






Kline                    Expires April 06, 2016                 [Page 8]

Internet-Draft            MPVD Application API              October 2015


              Narten, T. and H. Alvestrand, "Guidelines for Writing an
              IANA Considerations Section in RFCs", draft-narten-iana-
              considerations-rfc2434bis-09 (work in progress), March
              2008.

   [RFC2629]  Rose, M., "Writing I-Ds and RFCs using XML", RFC 2629,
              June 1999.

   [RFC3552]  Rescorla, E. and B. Korver, "Guidelines for Writing RFC
              Text on Security Considerations", BCP 72, RFC 3552, July
              2003.

Appendix A.  Comparison with Android implementation

   This becomes an Appendix.

Author's Address

   Erik Kline (editor)
   Google Japan KK
   Roppongi 6-10-1
   Mori Tower, 26th floor
   Minato, Tokyo  106-6128
   JP

   Email: ek@google.com

























Kline                    Expires April 06, 2016                 [Page 9]
